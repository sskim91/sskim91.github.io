{"meta":{"title":"Amagrammer","subtitle":"아마그래머","description":null,"author":"sskim","url":"https://sskim91.github.io"},"pages":[{"title":"Categories","date":"2018-05-09T02:36:55.862Z","updated":"2018-05-09T02:36:55.862Z","comments":true,"path":"categories/index.html","permalink":"https://sskim91.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-05-09T02:36:55.861Z","updated":"2018-05-09T02:36:55.861Z","comments":true,"path":"about/index.html","permalink":"https://sskim91.github.io/about/index.html","excerpt":"","text":"sskim91"},{"title":"Tags","date":"2018-05-09T02:36:55.878Z","updated":"2018-05-09T02:36:55.878Z","comments":true,"path":"tags/index.html","permalink":"https://sskim91.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Intellij SVN 계정 변경하는 방법","slug":"Intellij-SVN-계정-변경하는-방법","date":"2018-12-20T06:25:23.000Z","updated":"2018-12-20T06:25:23.441Z","comments":true,"path":"2018/12/20/Intellij-SVN-계정-변경하는-방법/","link":"","permalink":"https://sskim91.github.io/2018/12/20/Intellij-SVN-계정-변경하는-방법/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"jQuery append, prepend, after, before 차이","slug":"jQuery-20180605-jQuery-append-prepend-after-before-차이","date":"2018-06-05T04:58:55.000Z","updated":"2018-12-20T04:23:30.347Z","comments":true,"path":"2018/06/05/jQuery-20180605-jQuery-append-prepend-after-before-차이/","link":"","permalink":"https://sskim91.github.io/2018/06/05/jQuery-20180605-jQuery-append-prepend-after-before-차이/","excerpt":"","text":"jQuery에서 DOM을 제어할 때 요소 앞에 넣느냐 뒤에 넣느냐의 메서드는 append() 또는 prepend(), after(), before() 를 많이 사용한다. 그런데 이 차이점이 각자 조금씩 다른데 stackoverflow 에서 단 하나의 이미지를 통해서 이해하기 쉽게 올려줘서 그것을 올려본다. .append(), prepend(), .after() and .before()","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"}]},{"title":"jEnv 자바 환경관리","slug":"Web-Developer-20180514-jEnv-자바-환경관리","date":"2018-05-14T01:16:54.000Z","updated":"2019-03-23T11:49:24.961Z","comments":true,"path":"2018/05/14/Web-Developer-20180514-jEnv-자바-환경관리/","link":"","permalink":"https://sskim91.github.io/2018/05/14/Web-Developer-20180514-jEnv-자바-환경관리/","excerpt":"","text":"Java 버전관리하는 jenvjenv 공식 사이트 jenv 정리 잘한 github 어디선가 들었다. 개발자라면 데이터베이스 3종 (MSSQL, MySQL, ORACLE) 은 알아서 붙을 줄 알아야되고 JAVA 개발자면 jdk 버전을 여러개 설치해놔야 된다고 했었다. 그중에서 mac에서는 jdk 버전을 관리하기위해 jenv를 사용할 수 있다. brew로 jenv 설치1$brew install jenv Bash 쉘을 쓸때와 zsh 쉘을 쓸때 설정이 틀리다. 나는 zsh 을 이용하기 때문에 아래와 같은 스크립트를 적용한다. Zsh 12$ echo 'export PATH=\"$HOME/.jenv/bin:$PATH\"' &gt;&gt; ~/.zshrc$ echo 'eval \"$(jenv init -)\"' &gt;&gt; ~/.zshrc Bash 12$ echo 'export PATH=\"$HOME/.jenv/bin:$PATH\"' &gt;&gt; ~/.bash_profile$ echo 'eval \"$(jenv init -)\"' &gt;&gt; ~/.bash_profile 이제 jenv 에 java 디렉터리가 설정된 경로를 추가해준다. 1$ jenv add /path/to/java/home 자바 디렉터리 경로까지 추가해줬으면 jenv versions 명령어로 jdk List를 확인할 수 있고 현재 사용되고 있는 jdk를 알수 있다. 1$jenv versions jenv를 사용하면 global 에서 사용할 자바버전, local (폴더) 내에서만 사용할 자바버전 , 쉘에서만 사용되는 자바버전을 설정할 수 있다. Configure global version1$ jenv global oracle64-1.6.0.39 Configure local version (per directory)1$ jenv local oracle64-1.6.0.39 Configure shell instance version1$ jenv shell oracle64-1.6.0.39","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"https://sskim91.github.io/tags/Homebrew/"},{"name":"jenv","slug":"jenv","permalink":"https://sskim91.github.io/tags/jenv/"}]},{"title":"Homebrew 정리","slug":"Web-Developer-20180511-Homebrew-정리","date":"2018-05-11T06:42:06.000Z","updated":"2019-03-23T11:48:19.568Z","comments":true,"path":"2018/05/11/Web-Developer-20180511-Homebrew-정리/","link":"","permalink":"https://sskim91.github.io/2018/05/11/Web-Developer-20180511-Homebrew-정리/","excerpt":"","text":"HomebrewHomebrew란 간단히 말해서 Mac용 패키지 관리자이다. 리눅스에서 데비안, 우분투는 apt-get-install로 패키지를 알아서 설치하고 CentOS 는 yum으로 설치하는데 Mac도 Homebrew라는 패키지관리자를 통해서 패키지를 쉽게 설치할수 있다. (brew를 통해 설치하면 패키지의 의존하는 패키지들도 알아서 설치해준다.) 개발하다가 또는 웹사이트를 탐험하다가 소프트웨어 및 사용하는 툴의 플러그인 들을 설치하는 방법들을 보면 Homebrew로 설치하라고 하는 README를 많이 볼 수 있다. 그런점을 봐도 Mac을 사용한다면 처음에 해야할 일은 아마도 Homebrew를 설치하는 일이 아닌가 싶다. Homebrew를 통해서 단순히 패키지만을 설치할 수 있을뿐만 아니라 구글 Chrome 이나 Java JDK 등 cask 명령어를 통해 응용 프로그램을 쉽게 설치할 수 있다. 그럼 일단 Homebrew를 설치해보자. 지금의 설명은 전부 다 Homebrew의 홈페이지에 자세히 나와있다. Hombrew 사이트 친절하게 한글로도 번역이되어있다. Hombrew를 설치하는 방법은 간단히 Mac의 터미널을 실행시키고 아래의 명령어만 입력하면된다. 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Homebrew를 설치를 완료하면 이제 brew 명령어를 통해서 패키지를 설치할 수 있다. 1brew install [패키지명] brew는 똑같은 패키지라도 버전별로 다르게 다운로드 할 수 있다. Homebrew는 전용 디렉터리에 패키지를 설치하고 환경설정 및 binary 파일을 심볼릭 링크로 연결시켜준다. 전용 디렉터리의 위치는 /usr/local/Cellar 에 있다. Cellar 밑으로 들어가보면 brew로 설치한 패키지 목록들이 나타낸다. 직접 경로로 들어가보지 않고 brew로 설치한 패키지 목록을 나타내는 명령어는 아래와 같다. 1brew list brew 명령어brew command 퍼옴.. brew에서 설치할 수 있는 패키지들을 formula 라고 한다. 자주쓰이는 명령어는 12345678brew list //현재 설치되어있는 패키지 목록brew search [formular] //패키지 검색brew remove [formula] //패키지 삭제 (uninstall도 가능)brew doctor // brew 사용시 오류를 체크brew info [formula] //패키지 정보brew upgrade [formual] // 패키지를 안써주면 현재 설치되어있는 패키지 전부 업그레이드 패키지 를 명시해주면 명시된 패키지만 업데이트brew update // Homebrew 업데이트brew cleanup //패키지의 모든 과거버전을 제거 아래 표는 참고로.. Command Consequence brew install foo Installs foo brew install --HEAD foo Installs the HEAD version of foo, if foo defines such a version. brew install --force --HEAD foo Installs a newer HEAD version of foo. brew search Lists all formula that you can install brew search foo Searches for foo in formula available to install brew search /foo/ Same as above but parses /foo/ as a regex brew list Lists all installed formulae brew list foo Lists the installed files for foo brew info --github foo Open your browser at the Github History page for formula foo brew info Summarises all installed Homebrew packages brew info foo Gives all available information for installed or not installed formula foo brew home Open’s Homebrew’s homepage in your default browser brew home foo Opens foo’s homepage in your default browser brew update Update homebrew formulae and homebrew itself brew remove foo Uninstalls foo brew create [url] Generates a formula for the downloadable file at url and opens it in TextMate 1 brew create url-of-tarball --cache Generates a formula, then downloads the tarball. Adds the md5 to the formula template for you brew create --macports foo Open your browser at the MacPorts package search page, so you can see how they do foo brew create --fink foo Same thing, but for Fink brew edit foo Opens the formula in TextMate brew link foo Symlinks all of foo’s installed files into the Homebrew prefix 2 brew unlink foo Unsymlinks foo from the Homebrew prefix brew prune Removes dead symlinks from the Homebrew prefix 3 brew outdated Shows formula that have an updated version available . To install the new version of foo: brew install foo brew --config Print some useful system configuration to the console brew --prefix Display the real path to your Homebrew prefix (Usually /usr/local) brew --prefix (formula) Display the path where this formula is installed brew --cellar Display the real path to your Homebrew Cellar (Usually /usr/local/Cellar) brew --cache Display the real path to where Homebrew caches downloads (Usually ~/Library/Caches/Homebrew) brew doctor Checks your installation for common issues brew audit Audits all formulae for common code and style issues brew cleanup foo For all installed or specific formulae, removes any older versions from the cellar 4 Homebrew CaskHomebrew Cask는 Homebrew의 확장 프로그램(?) 쯤으로 생각하면 되고 MacOS 응용 프로그램과 대형 바이너리 파일들을 우아하고(?) 단순하게 그리고 빠르게 받을 수 있게 해준다고 공식 홈페이지에 나와있다. Homebrew Cask 당연한 이야기지만 Cask를 사용하기 위해서는 먼저 Homebrew를 설치해야 한다. brew cask 명령어를 사용하기 전에 아래의 명령어를 일단 실행해야한다. 1brew tap caskroom/cask 우리가 보통 응용 프로그램을 다운로드 받을 때 받고싶은 응용 프로그램을 인터넷에 검색해서 공식 사이트에 들어가서 다운로드 받아서 설치까지 진행해야하는 번거로움(?)이 있지만 Homebrew Cask 를 사용하면 터미널을 키고 그냥 아래의 명령어만 쳐주면 된다. 1brew cask install google-chrome cask로 설치한 응용프로그램의 위치는 /usr/local/Caskroom 에 있다. Cask 명령어cask 명령어는 기존 brew 명령어와 다를게 없다. 단지 앞에 cask 만 하나 더 들어가있다. 123brew cask search &lt;program&gt; //응용 프로그램 검색brew cask install &lt;program&gt; //응용 프로그램 설치brew cask uninstall &lt;program&gt; //응용 프로그램 제거 나는 현재 java를 버전별로 cask 명령어를 통해 설치해 놓음","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"https://sskim91.github.io/tags/Homebrew/"},{"name":"Homebrew Cask","slug":"Homebrew-Cask","permalink":"https://sskim91.github.io/tags/Homebrew-Cask/"}]},{"title":"JS Array 메서드 정리","slug":"JavaScript-20180510-JS-Array-메서드-정리","date":"2018-05-10T06:34:53.000Z","updated":"2018-05-10T06:51:33.403Z","comments":true,"path":"2018/05/10/JavaScript-20180510-JS-Array-메서드-정리/","link":"","permalink":"https://sskim91.github.io/2018/05/10/JavaScript-20180510-JS-Array-메서드-정리/","excerpt":"","text":"JavaScript Array Reference자바스크립트 배열 객체에 대해서 정리. 참고 사이트는 w3schhols-JS 들어가기 전 자바스크립트는 5가지 자료형 number, string, boolean, undefined, null을 제외한 모든 것은 객체이다. 라는것을 알고 들어가야한다. 배열도 객체 함수도 객체!! 이다. 배열 객체는 여러개의 값을 하나의 단일 변수에 저장하는데 사용된다. 배열의 인덱스는 첫번째 요소를 기준으로 0부터 시작한다. Array Properties 배열 속성 속성 설명 constructor Array 객체 프로토타입을 생성한 함수를 반환 length Array 요소 안의 개수를 반환 prototype Array 객체에 속성 및 메서드를 추가 할 수 있다. Array Methods 배열 메서드concat() 메서드concat () 메서드는 두 개 이상의 배열을 조인하는 데 사용된다. 이 메서드는 기존 배열을 변경하지 않지만 조인 된 배열의 값이 들어있는 새 배열을 반환한다. 123456789#사용법array1.concat(array2, array3, ..., arrayX);#예제var hege = [\"Cecilie\", \"Lone\"];var stale = [\"Emil\", \"Tobias\", \"Linus\"];var children = hege.concat(stale);#결과children(5) [\"Cecilie\", \"Lone\", \"Emil\", \"Tobias\", \"Linus\"] copyWithin() 메서드copyWithin () 메서드는 배열 내의 요소를 지정된 위치로 복사하고 지정한 위치에서 부터 복사해서 새로운 배열을 반환한다. 설명이 어렵다. ECMAScript 6 부터 사용가능 문법 1array.copyWithin(target, start, end); 매개변수 값 Parameter 설명 target 필수. 요소가 복사되는 인덱스의 위치를 지정 start 선택적. 요소 복사를 시작할 인덱스의 위치 (기본값은 0) end 선택적. 요소 복사 마지막 인덱스의 위치 (기본값은 array의 lenght 값) 1234567891011121314151617181920#예제var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.copyWithin(2, 0);(4) [\"Banana\", \"Orange\", \"Banana\", \"Orange\"]0:\"Banana\"1:\"Orange\"2:\"Banana\"3:\"Orange\"#예제2var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\", \"Kiwi\", \"Papaya\"];fruits.copyWithin(2, 0, 2);(6) [\"Banana\", \"Orange\", \"Banana\", \"Orange\", \"Kiwi\", \"Papaya\"]0:\"Banana\"1:\"Orange\"2:\"Banana\"3:\"Orange\"4:\"Kiwi\"5:\"Papaya\"length:6 예제 2만 설명 해보면 fruits.copyWithin(2,0,2); 이다. 복사되는 인덱스의 위치를 2로 잡았다. 0을 기준으로 시작되기 때문에 위의 fruits 배열의 Apple 부터 복사가 시작된다. 그리고 start 값은 0으로 friuts 배열의 0번째 부터 부터 시작하겠다는 의미이다. 그리고 마지막 end 값은 fruits 배열의 몇 번째까지 복사를 하겠다는 의미이기 때문에 때문에 Banana 부터 2번째 Apple 이전! 까지 복사하겠다는 명령이다. (start는 포함하고 end는 포함하지 않는 것 같다.) 그래서 결과를 살펴보면 위와 같이 나온다. entries() 메서드key/value 쌍의 형식으로 Array Iterator 객체를 만들어서 반환한다. 원래 배열에 대해서 각 항목의 관한 순서가 key 값으로 그리고 기존 배열에 들어있던 값이 value로 나타내진다. ECMAScript6에서 사용 -&gt; 일단 보류 every() 메서드every() 메서드는 배열의 모든 요소를 순회하면서 특정 조건을(함수) 배열의 값들이 만족시키는지 검사하는 메서드이다. every () 메서드는 배열에있는 각 요소에 대해 함수를 한 번 실행한다. 함수가 false 값을 반환하는 배열 요소를 찾으면 every ()은 false를 반환하고 나머지 값은 확인하지 않는다. false가 발생하지 않으면 every ()는 true를 반환한다. every()는 값없이 배열 요소에 대해 함수를 실행하지 않는다. every()는 원래 배열을 변경하지 않는다. 리턴 값은 Boolean 값으로 리턴한다. 문법 1array.every(function(currentValue, index, arr), thisValue); 매개변수 값 Parameter 설명 function(currentValue, index, arr) 필수. 배열을 순회하면서 요소에 대해서 실행할 함수currentValue = 필수. 현재 순회되고 있는 요소에 대한 값index = 선택. 현재 배열 요소의 인덱스arr = 선택. 현재 요소가 속한 배열 객체 thisValue 선택. 함수에 전달되어 “this”값으로 사용될 값입니다.이 매개 변수가 비어 있으면 값 “undefined”가 “this”값으로 전달됩니다. 1234567891011121314151617181920#예제function isBelowThreshold(currentValue) &#123; return currentValue &lt; 40;&#125;var array1 = [1, 40, 39, 29, 10, 13];console.log(array1.every(isBelowThreshold));// expected output: true#예제2function isBigEnough(element, index, array) &#123; console.log(element); return element &gt;= 10;&#125;[12, 5, 8, 130, 44].every(isBigEnough); // false[12, 54, 18, 130, 44].every(isBigEnough); // true// element는 현재 배열에서 순회하고 있는 요소이다.// arr은 현재 배열 객체 fill() 메서드fill() 메서드는 배열의 모든 요소를 정적 값으로 채 웁니다. fill() 시작 및 끝 인덱스를 지정할 수 있습니다. 기본적으로 전체 배열을 변경한다. 리턴 값은 변경된 배열을 반환한다. ECMAScript 6 부터 사용가능 문법 1array.fill(value, start, end); 매개변수 값 Parameter 설명 value 필수. 배열을 채우기 위한 값 start 선택. 시작 인덱스, 기본 값은 0 end 선택. 끝 인덱스, 기본 값은 배열의 길이 예제 123456789101112var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.fill(\"Kiwi\", 2, 4);//결과 (4) [\"Banana\", \"Orange\", \"Kiwi\", \"Kiwi\"][1, 2, 3].fill(4) // [4, 4, 4][1, 2, 3].fill(4, 1) // [1, 4, 4][1, 2, 3].fill(4, 1, 2) // [1, 4, 3][1, 2, 3].fill(4, 1, 1) // [1, 2, 3][1, 2, 3].fill(4, -3, -2) // [4, 2, 3][1, 2, 3].fill(4, NaN, NaN) // [1, 2, 3][].fill.call(&#123; length: 3 &#125;, 4) // &#123;0: 4, 1: 4, 2: 4, length: 3&#125; filter() 메서드filter () 메서드는 테스트를 통과 한 모든 배열 요소로 채워진 배열을 만듭니다 (함수로 제공). 참고 : filter ()는 값이없는 배열 요소에 대해 함수를 실행하지 않습니다. 참고 : filter ()는 원래 배열을 변경하지 않습니다. 반환 값으로는 조건을 만족한 요소가 들어있는 새로운 배열로 반환된다. 문법 1array.filter(function(currentValue, index, arr), thisValue); 매개변수 값 Parameter 설명 콜백함수 function(currentValue, index, arr) 필수. 배열의 각 요소를 테스트 하는 함수. 인수(currentValue, index, arr)와 함께 호출currentValue = 필수 .배열에서 현재 처리 중인 요소index = 선택. 배열에서 현재 처리 중인 요소의 인덱스arr = 선택. 현재 filter()를 실행하고 있는 배열 객체 (자기 자신이라고 생각하면 됨) thisValue 선택. 함수에 전달되어서 “this”값으로 사용될 값이다.이 매개변수가 비어 있으면 값 undefined가 this 값으로 전달됨 예제 12345678910111213141516171819202122232425262728293031323334353637383940#값이 10 이하인 조건을 만족하는 요소만을 새로운 배열로 반환function isBigEnough(value) &#123; return value &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered 는 [12, 130, 44]#JSON 에서 filter#id가 0이 아닌, 그리고 숫자인 모든 JSON 객체를 새로운 배열로 반환var arr = [ &#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;, &#123; &#125;, &#123; id: null &#125;, &#123; id: NaN &#125;, &#123; id: 'undefined' &#125;];var invalidEntries = 0;function filterByID(obj) &#123; if ('id' in obj &amp;&amp; typeof(obj.id) === 'number' &amp;&amp; !isNaN(obj.id)) &#123; return true; &#125; else &#123; invalidEntries++; return false; &#125;&#125;var arrByID = arr.filter(filterByID);console.log('Filtered Array\\n', arrByID);// Filtered Array// [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;]console.log('Number of Invalid Entries = ', invalidEntries);// Number of Invalid Entries = 4 find() 메서드find() 메서드는 해당 배열 안의 값을 하나! 반환합니다. 이때 콜백함수가 요구하는 조건에서 만족하는 값 하나 만을 반환한다. 조건에 맞는 값을 찾으면 해당 요소의 값을 바로 반환하고 그렇지 않으면 undefined를 반환한다. 참고 - find() 메서드는 값이 없는 배열 요소에 대해 함수를 실행하지 않는다. 참고 - find() 메서드는 기존의 배열을 변경하지 않는다. ECMAScript6 문법 1array.find(function(currentValue, index, arr), thisValue); 매개변수 값 Parameter 설명 콜백함수 function(currentValue, index, arr) 필수. 배열의 각 요소를 테스트 하는 함수. 인수(currentValue, index, arr)와 함께 호출currentValue = 필수 .배열에서 현재 처리 중인 요소index = 선택. 배열에서 현재 처리 중인 요소의 인덱스arr = 선택. 현재 filter()를 실행하고 있는 배열 객체 (자기 자신이라고 생각하면 됨) thisValue 선택. 함수에 전달되어서 “this”값으로 사용될 값이다.이 매개변수가 비어 있으면 값 undefined가 this 값으로 전달됨 예제 1234567891011121314151617181920212223242526#속성 중 하나를 사용하여 배열에서 객체 찾기var inventory = [ &#123;name: 'apples', quantity: 2&#125;, &#123;name: 'bananas', quantity: 0&#125;, &#123;name: 'cherries', quantity: 5&#125;];function findCherries(fruit) &#123; return fruit.name === 'cherries';&#125;console.log(inventory.find(findCherries)); // &#123; name: 'cherries', quantity: 5 &#125;#배열에서 소수 찾기function isPrime(element, index, array) &#123; var start = 2; while (start &lt;= Math.sqrt(element)) &#123; if (element % start++ &lt; 1) &#123; return false; &#125; &#125; return element &gt; 1;&#125;console.log([4, 6, 8, 12].find(isPrime)); // undefined, not foundconsole.log([4, 5, 8, 12].find(isPrime)); // 5 findIndex() 메서드findIndex() 메서드는 find() 와 같지만 다른 점은 반환 값을 find 메서드는 요소의 값을 반환 했다면 findIndex 는 요소의 인덱스를 반환한다. 기본적으로 callback 함수에서 조건에 만족하는 값이 있으면 그 요소의 인덱스를 반환하고 그렇지 않으면 -1을 반환한다. ECMAScript6 사용 문법 1array.findIndex(function(currentValue, index, arr), thisValue); 매개변수 값 Paramter 설명 callback function(currentValue, index, arr); 필수. 배열의 각 요소에 대해서 실행할 함수currentValue = 필수 .배열에서 현재 처리 중인 요소index = 선택. 배열에서 현재 처리 중인 요소의 인덱스arr = 선택. 현재 forEach()를 실행하고 있는 배열 객체 (자기 자신이라고 생각하면 됨) thisValue 선택. 함수에 전달되어서 “this”값으로 사용될 값이다.이 매개변수가 비어 있으면 값 undefined가 this 값으로 전달됨 예제 12345678910111213#배열에서 소수 index 찾기function isPrime(element, index, array) &#123; var start = 2; while (start &lt;= Math.sqrt(element)) &#123; if (element % start++ &lt; 1) &#123; return false; &#125; &#125; return element &gt; 1;&#125;console.log([4, 6, 8, 12].findIndex(isPrime)); // -1, not foundconsole.log([4, 6, 7, 12].findIndex(isPrime)); // 2 forEach() 메서드forEach () 메서드는 배열의 각 요소에 대해 한 번 제공된 함수를 차례로 호출합니다. Note : forEach () 메서드는 값이없는 배열 요소에 대해 함수를 실행하지 않습니다. 문법 1array.forEach(function(currentValue, index, arr), thisValue); 매개변수 값 Parameter 설명 callback function(currentValue, index, arr); 필수. 배열의 각 요소에 대해서 실행할 함수currentValue = 필수 .배열에서 현재 처리 중인 요소index = 선택. 배열에서 현재 처리 중인 요소의 인덱스arr = 선택. 현재 forEach()를 실행하고 있는 배열 객체 (자기 자신이라고 생각하면 됨) thisValue 선택. 함수에 전달되어서 “this”값으로 사용될 값이다.이 매개변수가 비어 있으면 값 undefined가 this 값으로 전달됨 예제 1234567891011121314151617181920212223var sum = 0;var numbers = [65, 44, 12, 4];function myFunction(item) &#123; sum += item;&#125;numbers.forEach(myFunction);console.log(sum); // 125######function logArrayElements(element, index, array) &#123; console.log('a[' + index + '] = ' + element);&#125;// 인덱스 2는 배열의 그 위치에 항목이 없기에// 건너뜀을 주의하세요.[2, 5, , 9].forEach(logArrayElements);// 기록:// a[0] = 2// a[1] = 5// a[3] = 9 from() 메서드 includes() 메서드includes() 메서드는 배열에 지정된 요소가 포함되어 있는지 여부를 검색한다. 이 메서드는 배열에 요소가 포함되어 있으면 true를 반환하고 그렇지 않으면 false 를 반환한다. 참고 - includes() 메서드는 대/소문자를 구분한다. 문법 1array.inludes(element, start); 매개변수 값 Parameter 설명 element 필수. 검색할 요소 start 선택. 기본값은 0, 배열의 시작할 위치를 지정해줄 수 있다. 예제 123var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];console.log(fruits.includes(\"Banana\", 1)); // falseconsole.log(fruits.includes(\"Banana\", 0)); // true indexOf() 메서드indexOf() 메서드는 배열에 있는 특정한 아이템을 찾아서 그 아이템의 index 위치를 반환한다. 사용자가 지정한 위치에서부터 검색을 시작할 수 있으며 시작 위치가 지정되지 않으면 배열의 처음부터 시작해서 끝에서 검색을 종료한다. 만약 만족하는 아이템을 찾지 못했을 경우 -1을 리턴한다. 만약 찾으려는 아이템이 1개 이상이 나오면 indexOf 메서드는 첫 번째 아이템의 위치만 반환한다. Note - 첫번째 아이템의 위치는 0부터 시작한다.. 0,1,2,…. 리턴 값은 Number 타입 문법 1array.indexOf(item, start); 매개변수 값 Parameter 설명 item 필수요소. 검색할 아이템 값 start 선택. 시작위치를 어디서 부터 할지 지정하는 숫자. 음수 값은 끝에서 부터 검색한다. 예제 1234567891011121314var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\", \"Banana\", \"Orange\", \"Apple\"];var a = fruits.indexOf(\"Apple\", 4);console.log(a); // 6// Create an array. (The elements start at index 0.)var ar = [\"ab\", \"cd\", \"ef\", \"ab\", \"cd\"];console.log(ar.indexOf(\"cd\")) // 1console.log(ar.indexOf(\"cd\",2)) // 4console.log(ar.indexOf(\"gh\")) // -1// Find \"ab\" with a fromIndex argument of -2.// The search starts at index 3, which is the array length plus -2.console.log(ar.indexOf(\"ab\",-2)) // 3 isArray() 메서드isArray() 메서드는 객체가 배열인지 여부를 확인한다. 이 메서드는 객체가 배열이면 true를 반환하고 배열이 아니면 false를 반환한다. 리턴되는 타입은 Boolean 값이고 ECMAScript5 부터 사용가능하다. 문법 1Array.isArray(obj); 매개변수 값 Parameter 설명 obj 필수. 테스트할 객체 예제 123456789101112131415161718192021222324252627282930313233343536var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];console.log(Array.isArray(fruits)); // true// 아래와 같이 호출하면 true 가 리턴됩니다.Array.isArray([]);Array.isArray([1]);Array.isArray(new Array());// 잘 알려지지 않은 사실 : Array.prototype 자체도 array 입니다.Array.isArray(Array.prototype);// 아래와 같이 호출하면 false 가 리턴됩니다.Array.isArray();Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(17);Array.isArray('Array');Array.isArray(true);Array.isArray(false);Array.isArray(&#123; __proto__: Array.prototype &#125;);var ar = [];var result = Array.isArray(ar);// Output: truevar ar = new Array();var result = Array.isArray(ar);// Output: truevar ar = [1, 2, 3];var result = Array.isArray(ar);// Output: truevar result = Array.isArray(\"an array\");document.write(result);// Output: false join() 메서드join() 메서드는 배열안의 요소를 지정한 문자열로 조인하고 문자열을 반환한다. 지정한 string 값이 없으면 배열의 값은 콤마로 구분된다. seperate 값은 기본 값은 콤마(,) 이다. 배열의 요소가 undefined 또는 null이면 공백 문자열로 처리된다. 문법 1array.join(seperator); 매개변수 값 Parameter 설명 seperator 선택적. String에서 한 배열 요소와 다음 요소를 구분하는 데 사용되는 문자열입니다. 생략하면 배열 요소들은 쉼표로 구분됩니다. 예제 123456789var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];var energy = fruits.join(\" and \");console.log(energy); //Banana and Orange and Apple and Mangovar a = ['바람', '비', '불'];var myVar1 = a.join(); // myVar1에 '바람,비,불'을 대입var myVar2 = a.join(', '); // myVar2에 '바람, 비, 불'을 대입var myVar3 = a.join(' + '); // myVar3에 '바람 + 비 + 불'을 대입var myVar4 = a.join(''); // myVar4에 '바람비불'을 대입 keys() 메서드 lastIndexOf() 메서드lastIndexOf() 메서드는 indexOf() 메서드와 마찬가지로 배열에서 지정된 항목을 검색해서 그 인덱스를 반환한다. 그러나 차이점은 검색할 항목이 2개 이상 존재할 때 indexOf()은 첫번째 항목의 인덱스를 반환하지만 lastIndexOf() 메서드는 마지막으로 검색된 항목의 인덱스를 반환한다는 차이점이 있다. 검색된 값이 없을 경우 -1을 반환한다. 문법 1array.lastIndexOf(item, start); 매개변수 값 Parameter 설명 item 필수. 검색할 요소 start 선택. 예제 12345678910111213141516171819202122232425262728293031var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\", \"Banana\", \"Orange\", \"Apple\"];fruits.lastIndexOf(\"Apple\"); // 6var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\", \"Banana\", \"Orange\", \"Apple\"];fruits.lastIndexOf(\"Apple\", 4); // 2var a = [2, 5, 9, 2];a.lastIndexOf(2); // 3a.lastIndexOf(7); // -1var array = [2, 5, 9, 2];array.lastIndexOf(2); // 3array.lastIndexOf(7); // -1array.lastIndexOf(2, 3); // 3array.lastIndexOf(2, 2); // 0array.lastIndexOf(2, -2); // 0array.lastIndexOf(2, -1); // 3#lastIndexOf()를 사용하여 지정된 배열의 요소 인덱스를 찾아서 새로운 배열에 pushvar indices = [];var array = ['a', 'b', 'a', 'c', 'a', 'd'];var element = 'a';var idx = array.lastIndexOf(element);while (idx != -1) &#123; indices.push(idx); idx = (idx &gt; 0 ? array.lastIndexOf(element, idx - 1) : -1);&#125;console.log(indices);// [4, 2, 0] map() 메서드map() 메서드는 각 배열을 순회하면서 모든 요소에 대해서 콜백 함수를 실행해서 그 결과로 새 배열을 만든다. map() 메서드는 배열의 각 요소에 대해 함수를 한번씩 차례대로 호출한다. 문법 1array.amp(function(currentValue, index, arr), thisValue); 매개변수 값 Parameter 설명 callback function(currentValue, index, arr); 필수. 배열의 각 요소에 대해서 실행할 함수currentValue = 필수 .배열에서 현재 처리 중인 요소index = 선택. 배열에서 현재 처리 중인 요소의 인덱스arr = 선택. 현재 map()를 실행하고 있는 배열 객체 (자기 자신이라고 생각하면 됨) thisValue 선택. 함수에 전달되어서 “this”값으로 사용될 값이다.이 매개변수가 비어 있으면 값 undefined가 this 값으로 전달됨 예제 123456789101112131415161718192021#배열에 들어있는 숫자들의 제곱근을 구하여 새로운 배열을 만들기var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);// roots의 값은 [1, 2, 3]이 되지만, numbers는 그대로 [1, 4, 9]입니다.#map을 활용해 오브젝트를 다시 재구성하기var kvArray = [&#123;key:1, value:10&#125;, &#123;key:2, value:20&#125;, &#123;key:3, value: 30&#125;];var reformattedArray = kvArray.map(function(obj)&#123; var rObj = &#123;&#125;; rObj[obj.key] = obj.value; return rObj;&#125;);// reformattedArray는 [&#123;1:10&#125;, &#123;2:20&#125;, &#123;3:30&#125;]가 되지만,// kvArray는 여전히 [&#123;key:1, value:10&#125;, &#123;key:2, value:20&#125;, &#123;key:3, value: 30&#125;]입니다.#숫자가 들어있는 배열을 인자가 있는 함수를 사용하여 재구성하기var numbers = [1, 4, 9];var doubles = numbers.map(function(num) &#123; return num * 2;&#125;);// doubles is now [2, 8, 18]. numbers is still [1, 4, 9] pop() 메서드pop() 메서드는 배열의 마지막 요소를 제거하고 그 요소를 반환한다. 참고 : 이 메서드는 배열의 length를 변경시킨다. 배열의 요소를 첫번째부터 제거하려면 shift() 메서드를 사용하면 된다. 문법 1array.pop() 매개변수 값 - None 예제 123456789101112131415161718var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.pop();//\"Mango\"fruits.pop();//\"Apple\"fruits.pop();//\"Orange\"var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];console.log(myFish); // ['angel', 'clown', 'mandarin', 'sturgeon']var popped = myFish.pop();console.log(myFish); // ['angel', 'clown', 'mandarin' ]console.log(popped); // 'sturgeon' push() 메서드push() 메서드는 배열의 끝에 하나 또는 그 이상의 요소를 추가하고 배열의 변경된 길이를 반환한다. 새로운 아이템은 배열의 끝에 추가 된다. 이 메서드는 배열의 길이를 변경시킨다. 새로 추가되는 아이템을 첫 번째 요소부터 추가시키려면 unshift() 메서드를 사용하면 된다. 문법 1array.push(item1, item2, ..., itemX); 매개변수 값 Parameter 설명 item1, item2, …, itemX 필수. 배열의 끝에 추가될 아이템 값 예제 123456789101112131415161718192021var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.push(\"Kiwi\", \"Lemon\", \"Pineapple\");//(7) [\"Banana\", \"Orange\", \"Apple\", \"Mango\", \"Kiwi\", \"Lemon\", \"Pineapple\"]#배열에 엘리먼트를 추가var sports = ['축구', '야구'];var total = sports.push('미식축구', '수영');console.log(sports); // ['축구', '야구', '미식축구', '수영']console.log(total); // 4#두 개의 배열을 합치기var vegetables = ['설탕당근', '감자'];var moreVegs = ['셀러리', '홍당무'];// 첫번째 배열에 두번째 배열을 합친다.// vegetables.push('셀러리', '홍당무'); 하는 것과 동일하다.Array.prototype.push.apply(vegetables, moreVegs);console.log(vegetables); // ['설탕당근', '감자', '셀러리', '홍당무'] reduce() 메서드reduece() 메서드는 왼쪽에서 오른쪽으로 이동하며 배열의 각 요소마다 누적 계산값과 함께 함수를 적용해 하나의 값으로 만들어서 반환한다. reduce() 메서드는 배열을 단일 값으로 만든다. reduce() 메서드는 각 요소에 대해 제공된 함수를 실행한다. (왼쪽에서 오른쪽으로) 문법 1array.reduce(functional(initialValue, currentValue, currentIndex, arr), initialValue); 매개변수 값 Parameter 설명 callback function( initialValue, currentValue, index, arr) 필수. 배열의 각 요소 값에 실행할 함수 initialValue - 누적 계산 값은 콜백의 반환 값을 누적한다.currentValue - 배열 내 현재 처리되고 있는 요소currentIndex - 배열 내 현재 처리되고 있는 요소의 인덱스. initialValue가 주어진 경우 0부터, 그렇지 않으면 1부터 시작array - reduce가 호출된 배열 initialValue 선택. callback의 첫 호출에 첫 번째 인수로 사용하는 값 예제 reduce 동작 설명 initialValue 인수 없을 때 123[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) &#123; return accumulator + currentValue;&#125;); 콜백은 4번 호출됩니다. 각 호출의 인수와 반환값은 다음과 같습니다. accumulator currentValue currentIndex array 반환값 1번째 호출 0 1 1 [0, 1, 2, 3, 4] 1 2번째 호출 1 2 2 [0, 1, 2, 3, 4] 3 3번째 호출 3 3 3 [0, 1, 2, 3, 4] 6 4번째 호출 6 4 4 [0, 1, 2, 3, 4] 10 reduce에 의해 반환되는 값은 마지막 콜백 호출의 반환값 (10)이 됩니다. 예제 reduce의 두 번째 인수로 초기값을 제공하는 경우, 결과는 다음과 같습니다: 123[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) &#123; return accumulator + currentValue;&#125;, 10); accumulator currentValue currentIndex array 반환값 1번째 호출 10 0 0 [0, 1, 2, 3, 4] 10 2번째 호출 10 1 1 [0, 1, 2, 3, 4] 11 3번째 호출 11 2 2 [0, 1, 2, 3, 4] 13 4번째 호출 13 3 3 [0, 1, 2, 3, 4] 16 5번째 호출 16 4 4 [0, 1, 2, 3, 4] 20 reduce가 결과로 반환된 값은 이 경우 20이 됩니다. reduceRight() 메서드 reverse() 메서드reverse() 메서드는 배열안의 요소 순서를 바꾼다. 역정렬 한다고 생각하면 된다. 문법 1array.reverse() 매개변수 값 - None 예제 12345678var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.reverse();(4) [\"Mango\", \"Apple\", \"Orange\", \"Banana\"]var myArray = ['one', 'two', 'three'];myArray.reverse();console.log(myArray) // ['three', 'two', 'one'] shift() 메서드shift() 메서드는 배열의 첫 번째 요소를 제거한다. 이 메서드는 배열의 길이를 변경시킨다. shift() 메서드로 삭제된 요소 값이 반환된다. 배열의 마지막 요소를 삭제하려면 pop() 메서드를 사용하면 된다. 문법 1array.shift() 매개변수 값 - None 예제 12345678910111213141516var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.shift(); //\"Banana\"fruits.shift(); //\"Orange\"var myFish = ['angel', 'clown', 'mandarin', 'surgeon'];console.log('myFish before: ' + myFish);// \"제거전 myFish 배열: angel,clown,mandarin,surgeon\"var shifted = myFish.shift();console.log('myFish after: ' + myFish);// \"제거후 myFish 배열: clown,mandarin,surgeon\"console.log('Removed this element: ' + shifted);// \"제거된 배열 요소: angel\" slice() 메서드slice() 메서드는 어떤 배열의 begin 부터 end까지 (end는 불포함)에 대한 선택된 요소를 새 배열 객체로 변환한다. 원래 배열 요소는 변경되지 않는다. 문법 1array.slice(start, end); 매개변수 값 Parameter 설명 begin 0을 시작으로 하는 추출 시작점에 대한 인덱스를 의미합니다.음수 인덱스는 배열의 끝에서부터의 길이를 나타냅니다. slice(-2) 는 배열에서 마지막 두 개의 엘리먼트를 추출합니다. end end가 생략되면 slice는 배열의 끝까지(arr.length) 추출합니다.추출을 종료 할 0 기준 인덱스입니다. slice 는 end 인덱스를 제외하고 추출합니다. 예를들어, slice(1,4)는 두번째 요소부터 네번째 요소까지 (1, 2 및 3을 인덱스로 하는 요소) 추출합니다. 음수 인덱스는 배열의 끝에서부터의 길이를 나타냅니다. 예를들어 slice(2,-1) 는 세번째부터 끝에서 두번째 요소까지 추출합니다. end가 생략되면 slice는 배열의 끝까지(arr.length) 추출합니다. 만약 end값이 배열의 길이보다 크다면, silce는 배열의 끝까지(arr.length) 추출합니다. 예제 12345678910111213141516var fruits = [\"Banana\", \"Orange\", \"Lemon\", \"Apple\", \"Mango\"];var myBest = fruits.slice(0, 2);console.log(mybest); //(2) [\"Banana\", \"Orange\"]#MSDN 예제var animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];console.log(animals.slice(2));// expected output: Array [\"camel\", \"duck\", \"elephant\"]console.log(animals.slice(2, 4));// expected output: Array [\"camel\", \"duck\"]console.log(animals.slice(1, 5));// expected output: Array [\"bison\", \"camel\", \"duck\", \"elephant\"] some() 메서드some() 메서드는 배열 내 일부 요소가 제공된 함수에 의해 구현된 테스트를 통과하는지를 검사합니다. some()은 callback이 true 값을 반환하는 요소를 찾을 때까지 배열에 있는 각 요소에 한 번 callback 함수를 실행합니다. 그런 요소가 발견된 경우, some() 은 그 즉시 true를 반환합니다. 그렇지 않으면 some()은 false를 반환합니다. 함수가 true 값을 반환하는 배열 요소를 찾으면 some()은 true를 반환하고 나머지 값은 확인하지 않는다. 그렇지 않은 경우는 false를 리턴 some()은 값 없이 배열 요소에 대해 함수를 실행하지 않는다. some()은 원래 배열을 변경하지 않는다. 문법 1array.some(function(currentValue, index, arr), thisValue) 매개변수 값 Parameter 설명 callback function(currentValue, index, arr); 필수. 배열의 각 요소에 대해서 실행할 함수currentValue = 필수 .배열에서 현재 처리 중인 요소index = 선택. 배열에서 현재 처리 중인 요소의 인덱스arr = 선택. 현재 some()을 실행하고 있는 배열 객체 (자기 자신이라고 생각하면 됨) thisValue 선택. 함수에 전달되어서 “this”값으로 사용될 값이다.이 매개변수가 비어 있으면 값 undefined가 this 값으로 전달됨 예제 123456789101112131415161718#배열 요소값 테스트function isBiggerThan10(element, index, array) &#123; return element &gt; 10;&#125;[2, 5, 8, 1, 4].some(isBiggerThan10); // false[12, 5, 8, 1, 4].some(isBiggerThan10); // true#값이 배열 내 존재하는지 확인var fruits = ['apple', 'banana', 'mango', 'guava'];function checkAvailability(arr, val) &#123; return arr.some(function(arrVal) &#123; return val === arrVal; &#125;);&#125;checkAvailability(fruits, 'kela'); //falsecheckAvailability(fruits, 'banana'); //true sort() 메서드 splice() 메서드splice() 메서드는 배열에 항목을 추가/ 제거하고 제거 된 항목을 반환합니다. 이 메서드는 기존 배열을 변경합니다. 문법 1array.splice(start, deleteCount, item1, ....., itemN) 매개변수 값 Parameter 설명 start 배열의 변경을 시작하는 인덱스입니다(초기 index : 0). 만약 배열 길이보다 길면 실제 시작 인덱스는 배열의 길이로 설정됩니다. 음수의 경우, 배열의 끝에서 부터 요소를 세어나가며 (초기 index : 1), 그 값의 절대값이 배열의 길이 보다 큰 경우 0으로 설정됩니다. deleteCount 배열에서 제거를 할 요소의 수 입니다. 만약 deleteCount가 0의 경우, 아무런 요소도 제거되지 않습니다. 이경우, 최소한 하나의 새 요소를 특정해 주어야 합니다. 만약, deleteCount가 start에서 부터의 남은 요소 수 보다 많을 경우, 남은 요소를 모두 제거합니다. itemN 배열에 추가될 요소입니다. 만약 아무런 요소도 특정되지 않을 경우, splice()는 요소를 오직 삭제만 한다. 예제 1234567var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];myFish.splice(2, 0, 'drum'); // 'drum'을 두번째 인덱스에 삽입// myFish is [\"angel\", \"clown\", \"drum\", \"mandarin\", \"sturgeon\"]myFish.splice(2, 1); // 두번째 인덱스에서 하나의 항목('drum')을 삭제// myFish is [\"angel\", \"clown\", \"mandarin\", \"sturgeon\"] toString() 메서드 unshift() 메서드unshift() 메서드는 push() 메서드와 반대로 배열에 새로운 아이템을 첫 번째 요소부터 추가하는 메서드이다. 그리고 새로운 길이를 반환한다. 이 메서드는 기존 배열의 길이를 변경한다. 새로운 요소를 뒤에서부터 삽입하려면 push() 메서드를 사용하면 된다. 문법 1array.unshift(item1, item2, ..., itemN); 매개변수 값 Parameter 설명 item1, item2, … itemN 필수. 배열에 추가할 요소 값 예제 12345678910var arr = [1, 2];arr.unshift(0); // result of call is 3, the new array length// arr is [0, 1, 2]arr.unshift(-2, -1); // = 5// arr is [-2, -1, 0, 1, 2]arr.unshift([-3]);// arr is [[-3], -2, -1, 0, 1, 2] valueOf() 메서드","categories":[{"name":"Programming","slug":"Programming","permalink":"https://sskim91.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://sskim91.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sskim91.github.io/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"https://sskim91.github.io/tags/Array/"}]},{"title":"Intellij Code Folding 해제하기","slug":"IDE-20180510-Intellij-Code-Folding-해제하기","date":"2018-05-10T01:33:23.000Z","updated":"2018-05-10T01:50:12.847Z","comments":true,"path":"2018/05/10/IDE-20180510-Intellij-Code-Folding-해제하기/","link":"","permalink":"https://sskim91.github.io/2018/05/10/IDE-20180510-Intellij-Code-Folding-해제하기/","excerpt":"","text":"Intellij Code Folding 해제하기Intellij 에서 코딩을 하다보면 한줄 짜리 코딩에서 중괄호가 들어가거나 HTML 태그 내에서 인라인 스타일을 적용했을 때 코드가 다 보이지 않고 {…}으로 표시되는 경우가 있다. 나 같은 경우에는 {…}으로 간략하게 표현하는 거 보다는 그냥 코드가 접히지 않고 다 보여줬으면 하는 마음에 구글링해서 알아보았더니 Intellij의 Folding setting을 건드려주면 된다. 아래와 같은 상황이 발생 Intellij IDEA Code Folding 코드상에서 Folding 기능을 접으려면 맥 기준으로 Cmd+ 을 누르면 된다. 마우스 오른쪽을 클릭해서 Folding 쪽을 보면 자세히 나와있다. 아예 옵션에서 바꾸려면 Setting &gt; General &gt; Code Folding 에서 Folding 기능을 해제하고 싶으면 해제하고 싶은 체크박스에 선택을 해제하면 된다. HTML, XML , 위에서 자바 코드에 getter setter 에서 folding 기능을 해제하고 싶으면 One-line method 를 해제하면 된다.","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"IDE","slug":"정리/IDE","permalink":"https://sskim91.github.io/categories/정리/IDE/"}],"tags":[{"name":"Intellij","slug":"Intellij","permalink":"https://sskim91.github.io/tags/Intellij/"}]},{"title":"Bootbox","slug":"JavaScript-Library-20180510-Bootstrap-Modal을-쉽게-사용하게-해주는-BootBox-js","date":"2018-05-10T00:54:43.000Z","updated":"2018-05-10T06:57:13.825Z","comments":true,"path":"2018/05/10/JavaScript-Library-20180510-Bootstrap-Modal을-쉽게-사용하게-해주는-BootBox-js/","link":"","permalink":"https://sskim91.github.io/2018/05/10/JavaScript-Library-20180510-Bootstrap-Modal을-쉽게-사용하게-해주는-BootBox-js/","excerpt":"Bootbox.js 소개Bootbox.js는 필요한 DOM 요소 또는 JS 이벤트 핸들러를 생성, 관리 또는 제거하는 것에 대해 걱정할 필요없이 부트 스트랩 모달을 사용하여 프로그래밍 방식 대화 상자를 만들 수있는 작은 JavaScript 라이브러리이다. 공식사이트Bootbox.js 사용방법 CDN https://cdnjs.cloudflare.com/ajax/libs/bootbox.js/4.4.0/bootbox.min.js 다운로드 위의 공식사이트에가서 다운로드 받아서 본인의 소스에 추가해서 사용하면 된다. Bootbox.js는 bootstrap의 모달을 이용하는 것이므로 bootstrap.js가 필요하고 bootstrap의 모달기능을 사용하기위해서는 jquery가 필요하므로 Bootbox.js를 사용하기 위해서는 bootstrap과 jquery를 추가해주어야 한다. 보통 이런 상황을 Bootbox.js가 bootstrap과 jquery에 의존한다고 한다.","text":"Bootbox.js 소개Bootbox.js는 필요한 DOM 요소 또는 JS 이벤트 핸들러를 생성, 관리 또는 제거하는 것에 대해 걱정할 필요없이 부트 스트랩 모달을 사용하여 프로그래밍 방식 대화 상자를 만들 수있는 작은 JavaScript 라이브러리이다. 공식사이트Bootbox.js 사용방법 CDN https://cdnjs.cloudflare.com/ajax/libs/bootbox.js/4.4.0/bootbox.min.js 다운로드 위의 공식사이트에가서 다운로드 받아서 본인의 소스에 추가해서 사용하면 된다. Bootbox.js는 bootstrap의 모달을 이용하는 것이므로 bootstrap.js가 필요하고 bootstrap의 모달기능을 사용하기위해서는 jquery가 필요하므로 Bootbox.js를 사용하기 위해서는 bootstrap과 jquery를 추가해주어야 한다. 보통 이런 상황을 Bootbox.js가 bootstrap과 jquery에 의존한다고 한다. 예제Bootbox.js는 크게 4가지 function을 사용할 수 있다. Alert prompt confirm Custom dialog 이제부터 각각 사용법을 간단한 예제로 작성해 보자!! Alert 예제12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Bootbox Example&lt;/title&gt; &lt;!-- css dependencies --&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button class=\"btn btn-info\" id=\"btn_click\"&gt;클릭&lt;/button&gt; &lt;/div&gt;&lt;!-- JS dependencies --&gt;&lt;script src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;!-- bootbox code --&gt;&lt;script src=\"js/bootbox.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function (e) &#123; $(\"#btn_click\").on(\"click\", function () &#123; bootbox.alert(\"This is the default alert!\"); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 기본 사용법 1bootbox.alert(&quot;Your message here…&quot;) alert()의 메시지를 작성하는 부분에는 HTML의 태그를 포함시켜서 나타낼 수 도 있다. 1bootbox.alert(\"Your message &lt;b&gt;here…&lt;/b&gt;\") 또 다른 사용법으로는 메시지 안에 콜백함수를 넣을 수가 있다. 1bootbox.alert(\"Your message here…\", function()&#123; /* your callback code */ &#125;) 옵션 예제 123456bootbox.alert(&#123; size: \"small\", title: \"Your Title\", message: \"Your message here…\", callback: function()&#123; /* your callback code */ &#125;&#125;) Bootbox 홈페이지에 가면 alert에 추가할 수 있는 옵션들을 문서로 제공하고 있다. Dialog Option 위에 나와있는 옵션 말고도 여러가지 옵션이 존재한다. Confirm 예제confirm function은 그냥 자바스크립트의 confirm 메소드와 비슷한 기능을 하는 function 같다. 실행을하면 기존 자바스크립트의 confirm 처럼 확인과 취소 버튼이 나온다. 확인을 누르면 true를 반환하고 취소를 누르면 false를 반환한다. 그리고 그냥 esc키로 dialog box를 끌 경우는 그냥 취소를 클릭한 것과 동일하게 처리한다. confirm dailog는 callback function이 필수 요소다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Bootbox Example&lt;/title&gt; &lt;!-- css dependencies --&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;button class=\"btn btn-info\" id=\"btn_click\"&gt;클릭&lt;/button&gt;&lt;/div&gt;&lt;!-- JS dependencies --&gt;&lt;script src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;!-- bootbox code --&gt;&lt;script src=\"js/bootbox.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function (e) &#123; $(\"#btn_click\").on(\"click\", function () &#123; bootbox.confirm(\"This is the default confirm!\", function(result)&#123; console.log('This was logged in the callback: ' + result); &#125;); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 여기에서는 확인 취소의 true false 값이 result로 들어간다. 기본 사용법 1bootbox.confirm(\"Are you sure?\", function(result)&#123; /* your callback code */ &#125;) 옵션을 추가한 사용법 12345bootbox.confirm(&#123; size: \"small\", message: \"Are you sure?\", callback: function(result)&#123; /* result is a boolean; true = OK, false = Cancel*/ &#125;&#125;) Prompt 예제prompt function도 confirm과 거의 같다. 다른 점은 confirm은 확인 취소 버튼만 있지만 prompt는 input box가 추가로 들어가 있다는 점 빼고는 같다. 사용방법도 같은 것 같다. promprt dailog도 callback fucntion이 필수다. 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Bootbox Example&lt;/title&gt; &lt;!-- css dependencies --&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;button class=\"btn btn-info\" id=\"btn_click\"&gt;클릭&lt;/button&gt;&lt;/div&gt;&lt;!-- JS dependencies --&gt;&lt;script src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;!-- bootbox code --&gt;&lt;script src=\"js/bootbox.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function (e) &#123; $(\"#btn_click\").on(\"click\", function () &#123; bootbox.prompt(\"This is the default prompt!\", function(result)&#123; alert(result); &#125;); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; dialog에 나온 input box의 값이 result로 들어온다. 기본 사용법 1bootbox.prompt(\"What is your name?\", function(result)&#123; /* your callback code */ &#125;) 옵션 추가 사용법 12345bootbox.prompt(&#123; size: \"small\", title: \"What is your name?\", callback: function(result)&#123; /* result = String containing user input if OK clicked or null if Cancel clicked */ &#125;&#125;) prompt dialog는 기본으로 하나의 input box를 가지고 있다. 그런데 여기서 prompt만 쓸 수 있는 옵션으로 다른 input type으로 수정할 수 있다. 속성명 설명 value value 옵션을 사용해서 prompt의 초기 값을 설정할 수 있다. inputType prompt dialog의 input type을 변경한다. text (기본), textarea, email, select, checkbox, date, time, number, password inputOptions inputType을 select 또는 checkbox로 선택했을 시에 해당 format을 적어줘야 한다. prompt options 예제 123456789101112131415161718192021bootbox.prompt(&#123; title: \"This is a prompt with a set of checkbox inputs!\", inputType: 'checkbox', inputOptions: [ &#123; text: 'Choice One', value: '1', &#125;, &#123; text: 'Choice Two', value: '2', &#125;, &#123; text: 'Choice Three', value: '3', &#125; ], callback: function (result) &#123; console.log(result); &#125;&#125;); 선택에 따라서 해당 value 값이 result로 반환된다. Custom Dialog 예제custom dialog는 사용자 정의 다이얼로그라고 생각하면 된다. custom dialog는 옵션 객체중에 하나의 인수만 허용하고 옵션 객체의 필수 속성은 message 속성이다. custom dialog도 여러 옵션을 사용할 수 있는데 그 부분은 공식 사이트 링크로 대체한다. Custom dialog option 기본 예제 123456var dialog = bootbox.dialog(&#123; message: '&lt;p class=\"text-center\"&gt;Please wait while we do something...&lt;/p&gt;', closeButton: false&#125;);// do something in the backgrounddialog.modal('hide'); init 예제 실행 하기전에 초기화를 한번 해준다. init function은 Bootbox.js 에 Public function이다. 123456789var dialog = bootbox.dialog(&#123; title: 'A custom dialog with init', message: '&lt;p&gt;&lt;i class=\"fa fa-spin fa-spinner\"&gt;&lt;/i&gt; Loading...&lt;/p&gt;'&#125;);dialog.init(function()&#123; setTimeout(function()&#123; dialog.find('.bootbox-body').html('I was loaded after the dialog was shown!'); &#125;, 3000);&#125;); 실행하면 3초뒤에 I was loaded after the dialog was shown! 메시지가 나타난다. Button 옵션 객체를 추가해서 해당 버튼을 클릭할 때마다 실행되는 콜백함수 예제 1234567891011121314151617181920212223242526272829var dialog = bootbox.dialog(&#123;title: 'A custom dialog with buttons and callbacks',message: \"&lt;p&gt;This dialog has buttons. Each button has it's own callback function.&lt;/p&gt;\",buttons: &#123; cancel: &#123; label: \"I'm a custom cancel button!\", className: 'btn-danger', callback: function()&#123; alert('Custom cancel clicked'); &#125; &#125;, noclose: &#123; label: \"I'm a custom button, but I don't close the modal!\", className: 'btn-warning', callback: function()&#123; alert('Custom button clicked'); return false; //return false를 명시해주면 버튼을 클릭해도 dialog box 화면이 꺼지지 않는다. &#125; &#125;, ok: &#123; label: \"I'm a custom OK button!\", className: 'btn-info', callback: function()&#123; alert('Custom OK clicked'); &#125; &#125;&#125;&#125;); 마무리사실 공식 홈페이지에 다 나와있는 거를 그냥 한번 정리하듯이 써 보았다. 공식 홈페이지에 가서 직접 보는게 오히려 이해가 더 빠를 것 같다. 그러나 Bootbox에 대한 포스팅이 별로 없길래 한번 작성해 보았다. 음..여러가지 틀린 점도 있을 수도 있지만 제대로 활용하려면 공식 사이트에 Documentation이 잘 되어있으니 확인하고 직접 예제를 실행해 보면서 멋진 웹 화면을 만들면 좋을 것 같다.","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"JS Library","slug":"정리/JS-Library","permalink":"https://sskim91.github.io/categories/정리/JS-Library/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sskim91.github.io/tags/JavaScript/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://sskim91.github.io/tags/Bootstrap/"}]},{"title":"jQuery API event.target","slug":"jQuery-20180419-jQuery-API-event-target","date":"2018-04-19T08:21:29.000Z","updated":"2019-03-23T11:30:13.741Z","comments":true,"path":"2018/04/19/jQuery-20180419-jQuery-API-event-target/","link":"","permalink":"https://sskim91.github.io/2018/04/19/jQuery-20180419-jQuery-API-event-target/","excerpt":"event.target 속성이벤트를 시작한 DOM 요소 리턴 값은 요소를 리턴한다. target 속성은 이벤트 또는 해당 이벤트의 자손에 대해 등록 된 요소가 될 수 있습니다. 이벤트 버블링으로 인해 이벤트가 처리되고 있는지 판별하기 위해 event.target을 this와 비교하는 것이 종종 유용합니다. 이 속성은 이벤트 위임에 매우 유용합니다.","text":"event.target 속성이벤트를 시작한 DOM 요소 리턴 값은 요소를 리턴한다. target 속성은 이벤트 또는 해당 이벤트의 자손에 대해 등록 된 요소가 될 수 있습니다. 이벤트 버블링으로 인해 이벤트가 처리되고 있는지 판별하기 위해 event.target을 this와 비교하는 것이 종종 유용합니다. 이 속성은 이벤트 위임에 매우 유용합니다. 예제클릭할 때마다 태그의 이름이 출력된다. event.target.nodename 을 확인 할 수 잇다. 12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;event.target demo&lt;/title&gt; &lt;style&gt; span, strong, p &#123; padding: 8px; display: block; border: 1px solid #999; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"log\"&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt; &lt;strong&gt;&lt;span&gt;click&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;&lt;/div&gt;&lt;script&gt;$( \"body\" ).click(function( event ) &#123; $( \"#log\" ).html( \"clicked: \" + event.target.nodeName );&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제간단한 이벤트 위임을 구현합니다. 클릭 핸들러가 순서가 지정되지 않은 목록에 추가되고 li 자식의 하위 항목이 숨겨집니다. li 자식 중 하나를 클릭하면 해당 자식을 토글합니다. 123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;event.target demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;item 1 &lt;ul&gt; &lt;li&gt;sub item 1-a&lt;/li&gt; &lt;li&gt;sub item 1-b&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;item 2 &lt;ul&gt; &lt;li&gt;sub item 2-a&lt;/li&gt; &lt;li&gt;sub item 2-b&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt;function handler( event ) &#123; var target = $( event.target ); if ( target.is( \"li\" ) ) &#123; target.children().toggle(); &#125;&#125;$( \"ul\" ).click( handler ).find( \"ul\" ).hide();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"}]},{"title":"jQuery API event.data 메서드","slug":"jQuery-20180419-jQuery-API-event-data","date":"2018-04-19T08:14:17.000Z","updated":"2018-05-10T01:22:16.029Z","comments":true,"path":"2018/04/19/jQuery-20180419-jQuery-API-event-data/","link":"","permalink":"https://sskim91.github.io/2018/04/19/jQuery-20180419-jQuery-API-event-data/","excerpt":"","text":"event.data예제도 좀 어렵고 이해가 안된다. 그런데 여기 jQuery tutorial Youtube 보고 좀 이해 됬음 youtube jquery tutorial W3SCHOOL 예제 설명 12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;event.data demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt; 0 &lt;/button&gt;&lt;button&gt; 1 &lt;/button&gt;&lt;button&gt; 2 &lt;/button&gt;&lt;button&gt; 3 &lt;/button&gt;&lt;button&gt; 4 &lt;/button&gt;&lt;div id=\"log\"&gt;&lt;/div&gt;&lt;script&gt;var logDiv = $( \"#log\" );for ( var i = 0; i &lt; 5; i++ ) &#123; $( \"button\" ).eq( i ).on( \"click\", &#123; value: i &#125;, function( event ) &#123; var msgs = [ \"button = \" + $( this ).index(), \"event.data.value = \" + event.data.value, \"i = \" + i ]; logDiv.append( msgs.join( \", \" ) + \"&lt;br&gt;\" ); &#125;);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"}]},{"title":"jQuery API toggleClass 메서드","slug":"jQuery-20180419-jQuery-API-toggleClass-메서드","date":"2018-04-19T08:11:03.000Z","updated":"2019-03-23T11:24:46.395Z","comments":true,"path":"2018/04/19/jQuery-20180419-jQuery-API-toggleClass-메서드/","link":"","permalink":"https://sskim91.github.io/2018/04/19/jQuery-20180419-jQuery-API-toggleClass-메서드/","excerpt":"toggleClass() 메서드는 하나 이상의 클래스 이름을 매개변수로 사용합니다. 첫번째 버전에서는 일치하는 요소 안에 class 속성이 이미 존재할 때는 그 class 명을 지웠다. 반대로 인자로 주어진 클래스 속성이 없으면 추가된다.","text":"toggleClass() 메서드는 하나 이상의 클래스 이름을 매개변수로 사용합니다. 첫번째 버전에서는 일치하는 요소 안에 class 속성이 이미 존재할 때는 그 class 명을 지웠다. 반대로 인자로 주어진 클래스 속성이 없으면 추가된다. 1&lt;div class=\"tumble\"&gt;Some text.&lt;/div&gt; toggleClass 적용시 $( “div.tumble” ).toggleClass( “bounce” ) 12//bounce가 추가되어있다.&lt;div class=\"tumble bounce\"&gt;Some text.&lt;/div&gt; 그 다음으로 아래 스크립트가 한번 더 실행되면 div 태그의 클래스는 원래대로 thumble만 남게된다. $( “div.tumble” ).toggleClass( “bounce” ) 1&lt;div class=\"tumble\"&gt;Some text.&lt;/div&gt; 동일한 div에 .toggleClass(“bounce spin”) 을 적용하면 1&lt;div class=\"tumble bounce spin\"&gt; 와 &lt;div class=\"tumble\"&gt; 가 반복하게 된다. toggleCalss 에 두번째 인수에는 true 나 false 값이 올 수있는데 인자로 넘어간 클래스가 해당 요소에 있을 경우 제거하고 없을 경우 추가 한다는 개념이다. $( “#foo” ).toggleClass( className, addOrRemove ); 아래와 동일한 코드 방식으로 작동한다. 12345if ( addOrRemove ) &#123; $( \"#foo\" ).addClass( className );&#125; else &#123; $( \"#foo\" ).removeClass( className );&#125; jQuery 1.4 버전 부터는 toglleClass() 메서드에 아무 인자도 적지 않으면 모든 클래스 요소 이름이 토글된다. 또한 jQuery 1.4 버전 부터는 토글 된 클래스 이름은 함수를 통해서 전달할 수도 있다. 아래 예제 1234567$( \"div.foo\" ).toggleClass(function() &#123; if ( $( this ).parent().is( \".bar\" ) ) &#123; return \"happy\"; &#125; else &#123; return \"sad\"; &#125;&#125;); 이 예제는 부모 요소에 bar 클래스가있는 경우 div class=”foo” 요소의 happy 클래스를 토글합니다. 그렇지 않으면 sad 클래스를 토글합니다. 예제p 태그를 클릭할 때마다 highlight 클래스가 토글된다. 123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;toggleClass demo&lt;/title&gt; &lt;style&gt; p &#123; margin: 4px; font-size: 16px; font-weight: bolder; cursor: pointer; &#125; .blue &#123; color: blue; &#125; .highlight &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"blue\"&gt;Click to toggle&lt;/p&gt;&lt;p class=\"blue highlight\"&gt;highlight&lt;/p&gt;&lt;p class=\"blue\"&gt;on these&lt;/p&gt;&lt;p class=\"blue\"&gt;paragraphs&lt;/p&gt;&lt;script&gt;$( \"p\" ).click(function() &#123; $( this ).toggleClass( \"highlight\" );&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;toggleClass demo&lt;/title&gt; &lt;style&gt; p &#123; margin: 4px; font-size: 16px; font-weight: bolder; cursor: pointer; &#125; .blue &#123; color: blue; &#125; .highlight &#123; background: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"blue\"&gt;Click to toggle (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt;&lt;p class=\"blue highlight\"&gt;highlight (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt;&lt;p class=\"blue\"&gt;on these (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt;&lt;p class=\"blue\"&gt;paragraphs (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt;&lt;script&gt;var count = 0;$( \"p\" ).each(function() &#123; var $thisParagraph = $( this ); var count = 0; $thisParagraph.click(function() &#123; count++; $thisParagraph.find( \"span\" ).text( \"clicks: \" + count ); $thisParagraph.toggleClass( \"highlight\", count % 3 === 0 ); &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"toggleClass","slug":"toggleClass","permalink":"https://sskim91.github.io/tags/toggleClass/"}]},{"title":"jQuery API toArray 메서드","slug":"jQuery-20180419-jQuery-API-toArray-메서드","date":"2018-04-19T08:10:00.000Z","updated":"2019-03-23T11:30:04.846Z","comments":true,"path":"2018/04/19/jQuery-20180419-jQuery-API-toArray-메서드/","link":"","permalink":"https://sskim91.github.io/2018/04/19/jQuery-20180419-jQuery-API-toArray-메서드/","excerpt":"toArray() 메서드jQuery 집합에 포함된 모든 요소를 배열로 반환 toArray() 메서드는 jQuery 선택자의 모든 jQuery 집합을 배열로 반환한다. 1alert( $( \"li\" ).toArray() ); 일치하는 모든 DOM 노드는 표준 배열에 포함 된 형태로 반환됩니다.","text":"toArray() 메서드jQuery 집합에 포함된 모든 요소를 배열로 반환 toArray() 메서드는 jQuery 선택자의 모든 jQuery 집합을 배열로 반환한다. 1alert( $( \"li\" ).toArray() ); 일치하는 모든 DOM 노드는 표준 배열에 포함 된 형태로 반환됩니다. 예제아래의 문서에서 모든 div를 선택하고 DOM 요소를 배열 반환한다. 그 이후에 내장 메서드인 reverse() 메서드를 사용해서 역정렬한다. 12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;toArray demo&lt;/title&gt; &lt;style&gt; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;Reversed - &lt;span&gt;&lt;/span&gt;&lt;div&gt;One&lt;/div&gt;&lt;div&gt;Two&lt;/div&gt;&lt;div&gt;Three&lt;/div&gt;&lt;script&gt;function disp( divs ) &#123; var a = []; for ( var i = 0; i &lt; divs.length; i++ ) &#123; a.push( divs[ i ].innerHTML ); &#125; $( \"span\" ).text( a.join( \" \" ) );&#125;disp( $( \"div\" ).toArray().reverse() );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"toArray","slug":"toArray","permalink":"https://sskim91.github.io/tags/toArray/"}]},{"title":"jQuery API prevAll 메서드","slug":"jQuery-20180419-jQuery-API-prevAll-메서드","date":"2018-04-19T08:09:06.000Z","updated":"2019-03-23T11:30:07.112Z","comments":true,"path":"2018/04/19/jQuery-20180419-jQuery-API-prevAll-메서드/","link":"","permalink":"https://sskim91.github.io/2018/04/19/jQuery-20180419-jQuery-API-prevAll-메서드/","excerpt":"prevAll() 메서드선택자로 선택된 요소 내의 이전 형제 요소들을 모두 선택해서 반환하는 메서드이다.","text":"prevAll() 메서드선택자로 선택된 요소 내의 이전 형제 요소들을 모두 선택해서 반환하는 메서드이다. .prevAll () 메소드는 DOM 요소 집합을 나타내는 jQuery 객체가 주어지면 DOM 트리에서 이들 요소의 이전 요소를 검색하여 일치하는 요소에서 새 jQuery 객체를 생성합니다. 요소는 가장 가까운 형제로 시작하여 순서대로 리턴됩니다. 메서드는 선택적으로 $ () 함수에 전달할 수있는 동일한 유형의 selector 표현식을 허용합니다. 선택기가 제공되면 요소가 일치하는지 테스트하여 요소를 필터링합니다. 예제로 살펴보고 이해하자 예제div 태그의 마지막 요소를 선택해서 이전 요소를 다 반환한다. 그리고 해당 요소에 before 클래스를 추가! 123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;prevAll demo&lt;/title&gt; &lt;style&gt; div &#123; width: 70px; height: 70px; background: #abc; border: 2px solid black; margin: 10px; float: left; &#125; div.before &#123; border-color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;$( \"div:last\" ).prevAll().addClass( \"before\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"prevAll","slug":"prevAll","permalink":"https://sskim91.github.io/tags/prevAll/"}]},{"title":"jQuery 속성 선택자 정리","slug":"jQuery-20180419-jQuery-속성-선택자-정리","date":"2018-04-19T08:05:28.000Z","updated":"2018-05-10T01:22:15.996Z","comments":true,"path":"2018/04/19/jQuery-20180419-jQuery-속성-선택자-정리/","link":"","permalink":"https://sskim91.github.io/2018/04/19/jQuery-20180419-jQuery-속성-선택자-정리/","excerpt":"","text":"jQuery 속성 선택자 정리jQuery는 CSS의 선택자(Selector) 방식을 사용해서 DOM에 접근한다. 선택자에는 여러 종류가 있는데, 자주 사용하는 선택자로는 id 선택자, class선택자, tag선택자 등이 있는데 아래 살펴볼 속성 선택자는 클래스 속성이나 id 속성과 같이 대표적인 속성이 아닌 태그 안의 특정 속성들에 따라 스타일을 지정한다. 속성 값의 조건에 따라 다양한 스타일을 지정할 수 있기 때문에 활용도가 높은 스타일 지정 방식이다. 패턴 의미 CSS Level 지원하지 않는브라우저 E[attr] ‘attr’ 속성이 포함된 요소 E를 선택합니다. 2 IE6 E[attr=”val”] ‘attr’ 속성의 값이 정확하게 ‘val’과 일치하는 요소 E를 선택합니다. 2 IE6 E[attr~=”val”] ‘attr’ 속성의 값에 ‘val’이 포함되는 요소를 선택합니다.(공백으로 분리된 값이 일치해야 합니다.) 2 IE6 E[attr^=”val”] ‘attr’ 속성의 값이 ‘val’으로 시작하는 요소를 선택합니다. 3 IE6 E[attr$=”val”] ‘attr’ 속성의 값이 ‘val’으로 끝나는 요소를 선택합니다. 3 IE6 E[attr*=”val”] ‘attr’ 속성의 값에 ‘val’이 포함되는 요소를 선택합니다. 3 IE6 E[attr\\ =”val”] ‘attr’ 속성의 값이 정확하게 ‘val’ 이거나’val-‘ 으로 시작되는 요소 E를 선택합니다. 2 IE6 예제를 통해서 하나하나씩 살펴보자 예제 Selector[name=”value”]“Hot Fuzz”라는 value 값을 가진 input 태그를 찾아서 text를 수정한다. 12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;attributeEquals demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"newsletter\" value=\"Hot Fuzz\"&gt; &lt;span&gt;name?&lt;/span&gt; &lt;/label&gt;&lt;/div&gt;&lt;div&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"newsletter\" value=\"Cold Fusion\"&gt; &lt;span&gt;value?&lt;/span&gt; &lt;/label&gt;&lt;/div&gt;&lt;div&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"newsletter\" value=\"Evil Plans\"&gt; &lt;span&gt;value?&lt;/span&gt; &lt;/label&gt;&lt;/div&gt;&lt;script&gt;$( \"input[value='Hot Fuzz']\" ).next().text( \"Hot Fuzz\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제 Selector [name~=”value”]value로 작성된 문자열에 선택자의 속성 값이 일치하면 그 값을 변경해준다. !!단 공백으로 분리된 값이 일치해야한다. 아래 예제를 보면 알겠지만 man이 들어간 input이 첫 번째와 세 번째가 있지만 두 번째 input만 공백으로 분리된 값이 일치하기 때문에 두 번째 input값만 변경되었다. 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;attributeContainsWord demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input name=\"man-news\"&gt;&lt;input name=\"milk man\"&gt;&lt;input name=\"letterman2\"&gt;&lt;input name=\"newmilk\"&gt;&lt;script&gt;$( \"input[name~='man']\" ).val( \"mr. man is in it!\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제 Selector [name*=”value”]위의 예제와 똑같지만 다른점은 선택자*= 는 속성의 값이 value 값을 포함하는 요소를 선택한다. 그래서 이번에는 첫 번째 두 번째 세 번째 input 모두 다 name 속성의 값에 man 이 포함 되기 때문에 3개 다 값이 채워진 것을 확인할 수 있다. 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;attributeContains demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input name=\"man-news\"&gt;&lt;input name=\"milkman\"&gt;&lt;input name=\"letterman2\"&gt;&lt;input name=\"newmilk\"&gt;&lt;script&gt;$( \"input[name*='man']\" ).val( \"has man in it!\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제 Selector [name|=”value”]선택자의 속성의 값이 value로 시작되거나 value-(하이픈) 으로 시작되는 요소를 선택한다. 아래 예제처럼 en과 en- 으로 시작되는 요소를 선택해서 css를 변경해주었다. 123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;attributeContainsPrefix demo&lt;/title&gt; &lt;style&gt; a &#123; display: inline-block; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"example.html\" hreflang=\"en\"&gt;Some text&lt;/a&gt;&lt;a href=\"example.html\" hreflang=\"en-UK\"&gt;Some other text&lt;/a&gt;&lt;a href=\"example.html\" hreflang=\"english\"&gt;will not be outlined&lt;/a&gt;&lt;script&gt;$( \"a[hreflang|='en']\" ).css( \"border\", \"3px dotted green\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제 Selector [name^=”value”]선택자의 속성이 value 로 시작!하는 요소를 선택한다. 그냥 value로 시작하는 값으로 시작 하기만 하면 선택된다. 12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;attributeStartsWith demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input name=\"newsletter\"&gt;&lt;input name=\"milkman\"&gt;&lt;input name=\"newsboy\"&gt;&lt;script&gt;$( \"input[name^='news']\" ).val( \"news here!\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제 Selector [name!=”value”]선택자의 속성 값이 value가 아닌! 요소를 선택한다. jQuery 공식 문서에서는 :not([attr=&#39;value&#39;])와 동등하다고 나와있다. 추가 노트로는 [name!=”value”] 는 CSS의 명세?부분이 아닌 jQuery의 확장 이다. [name!=”value”] 선택자는 순수 DOM 메서드인 querySelectorAll()의 빠른 퍼포먼스의 이점을 사용하지는 못한다. 최신 브라우저에서의 더 나은 퍼포먼스를 원한다면 $(&quot;your-pure-css-selector&quot;).not(&quot;[name=&#39;value&#39;]&quot;)를 사용하라고 나와있다! 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;attributeNotEqual demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;input type=\"radio\" name=\"newsletter\" value=\"Hot Fuzz\"&gt; &lt;span&gt;name is newsletter&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;input type=\"radio\" value=\"Cold Fusion\"&gt; &lt;span&gt;no name&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;input type=\"radio\" name=\"accept\" value=\"Evil Plans\"&gt; &lt;span&gt;name is accept&lt;/span&gt;&lt;/div&gt;&lt;script&gt;$( \"input[name!='newsletter']\" ).next().append( \"&lt;b&gt;; not newsletter&lt;/b&gt;\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제 Selector [name$=”value”]선택자의 속성 값이 value로 끝나는! 요소를 선택한다. 아래 예제만 봐도 이해가 될 것이다. 마지막에 letter로 끝나는 input에만 a letter라는 값이 추가되었다. 12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;attributeEndsWith demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input name=\"newsletter\"&gt;&lt;input name=\"milkman\"&gt;&lt;input name=\"jobletter\"&gt;&lt;script&gt;$( \"input[name$='letter']\" ).val( \"a letter\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"속성선택자","slug":"속성선택자","permalink":"https://sskim91.github.io/tags/속성선택자/"}]},{"title":"jQuery API get 메서드","slug":"jQuery-20180419-jQuery-API-get-메서드","date":"2018-04-19T08:03:41.000Z","updated":"2019-03-23T11:30:08.011Z","comments":true,"path":"2018/04/19/jQuery-20180419-jQuery-API-get-메서드/","link":"","permalink":"https://sskim91.github.io/2018/04/19/jQuery-20180419-jQuery-API-get-메서드/","excerpt":"get() 메서드jQuery 객체와 일치하는 DOM 요소를 가져온다. get() 메서드는 각 jQuery 객체의 기본 DOM 노드에 대한 액세스를 허용한다. index의 값이 범위를 벗어나는 경우 undefined 값을 반환한다. 아래의 코드를 통해서 확인해보자","text":"get() 메서드jQuery 객체와 일치하는 DOM 요소를 가져온다. get() 메서드는 각 jQuery 객체의 기본 DOM 노드에 대한 액세스를 허용한다. index의 값이 범위를 벗어나는 경우 undefined 값을 반환한다. 아래의 코드를 통해서 확인해보자 순서가 없는 간단한 리스트 1234&lt;ul&gt; &lt;li id=\"foo\"&gt;foo&lt;/li&gt; &lt;li id=\"bar\"&gt;bar&lt;/li&gt;&lt;/ul&gt; 특정한 인덱스를 명시해주면 .get(index) 메서드는 단일 요소를 검색한다. 1console.log( $( \"li\" ).get( 0 ) ); index는 0을 기준으로 첫번째 리스트의 item을 반환한다. 1위의 ul 리스트에서는 &lt;li id=\"foo\"&gt; 가 반환된다. 또한 각각의 jQuery 객체는 배열로 위장하고 있다.. 이말이 뭔 즉슨 jQuery 객체에는 조회된 엘리먼트가 담겨있는데 jQuery 객체는 자바스크립트 일종의 유사배열의 형태로 조회된 엘리먼트를 가지고 있기 때문에 배열의 형태로 아이템을 가지고 올 수 있다. 123console.log( $( \"li\" )[ 0 ] );//그러나 이런 구문에서는 음수 인덱스 지정과 같은 .get ()의 추가 기능이 없다.console.log($(\"li\")[-1]); // 이런건 안됨!!!!! get() 메서드는 음수 인덱스를 지정해 줄수 일치하는 요소의 끝에서 부터 계산된다. 1console.log( $( \"li\" ).get( -1 ) ); 12//이렇게 하면 아래와 같이 반환된다.&lt;li id=\"bar\"&gt; 예제를 통해서 더 알아보자 예제요소를 클릭할 때 태그 이름이 나타나는 예제 12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;get demo&lt;/title&gt; &lt;style&gt; span &#123; color: red; &#125; div &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;p&gt;In this paragraph is an &lt;span&gt;important&lt;/span&gt; section&lt;/p&gt;&lt;div&gt;&lt;input type=\"text\"&gt;&lt;/div&gt;&lt;script&gt;$( \"*\", document.body ).click(function( event ) &#123; event.stopPropagation(); var domElement = $( this ).get( 0 ); $( \"span:first\" ).text( \"Clicked on - \" + domElement.nodeName );&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; argument가 없는 get() 메서드 .get() This method does not accept any arguments. 바로 확인해보자 1234&lt;ul&gt; &lt;li id=\"foo\"&gt;foo&lt;/li&gt; &lt;li id=\"bar\"&gt;bar&lt;/li&gt;&lt;/ul&gt; index값이 없이 .get() 메서드를 사용하면 배열 형태로 모든 요소가 반환된다. 1console.log( $( \"li\" ).get() ); 결과는 일치하는 모든 DOM 노드들이 표준 배열을 포함하는 형태로 반환된다. 아래와 같이!! 1[&lt;li id=\"foo\"&gt;, &lt;li id=\"bar\"&gt;] 예제문서내에서 모든 div 요소를 선택하고 배열로 DOM 요소를 반환한다. reverse() 메서드는 배열을 역순으로 정렬한다. 123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;get demo&lt;/title&gt; &lt;style&gt; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;Reversed - &lt;span&gt;&lt;/span&gt;&lt;div&gt;One&lt;/div&gt;&lt;div&gt;Two&lt;/div&gt;&lt;div&gt;Three&lt;/div&gt;&lt;script&gt;function display( divs ) &#123; var a = []; for ( var i = 0; i &lt; divs.length; i++ ) &#123; a.push( divs[ i ].innerHTML ); &#125; $( \"span\" ).text( a.join(\" \") );&#125;display( $( \"div\" ).get().reverse() );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"get","slug":"get","permalink":"https://sskim91.github.io/tags/get/"}]},{"title":"jQuery API find 메서드","slug":"jQuery-20180419-jQuery-API-find-메서드","date":"2018-04-19T08:02:41.000Z","updated":"2019-03-23T11:30:02.534Z","comments":true,"path":"2018/04/19/jQuery-20180419-jQuery-API-find-메서드/","link":"","permalink":"https://sskim91.github.io/2018/04/19/jQuery-20180419-jQuery-API-find-메서드/","excerpt":"find() 메서드선택자, jQuery 객체 요소를 찾아서 일치하는 요소의 하위 요소를 찾는 메서드 즉 인자로 넘어간 선택자의 하위 요소를 찾아준다. find()와 children() 의 차이점은 find()는 DOM 레벨 트리에서 요소의 모든 자식 요소를 검색하고 children()은 DOM 레벨 트리에서 바로 아래 단계 자식 요소만을 추출하는 점에서 차이가 있다. 예제를 보자","text":"find() 메서드선택자, jQuery 객체 요소를 찾아서 일치하는 요소의 하위 요소를 찾는 메서드 즉 인자로 넘어간 선택자의 하위 요소를 찾아준다. find()와 children() 의 차이점은 find()는 DOM 레벨 트리에서 요소의 모든 자식 요소를 검색하고 children()은 DOM 레벨 트리에서 바로 아래 단계 자식 요소만을 추출하는 점에서 차이가 있다. 예제를 보자 예제12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;find demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;, how are you?&lt;/p&gt;&lt;p&gt;Me? I'm &lt;span&gt;good&lt;/span&gt;.&lt;/p&gt;&lt;script&gt;$( \"p\" ).find( \"span\" ).css( \"color\", \"red\" );//same as $(\"p span\")&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; p 태그 밑에 자식인 span 태그 모두 css를 적용 인자를 선택자 태그 span으로 넣었다. 위의 예제는 $(“p span”) 으로 해도 된다. 12345678910111213141516171819202122232425&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;find demo&lt;/title&gt; &lt;style&gt; span &#123; color: blue; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;, how are you?&lt;/p&gt;&lt;p&gt;Me? I'm &lt;span&gt;good&lt;/span&gt;.&lt;/p&gt;&lt;div&gt;Did you &lt;span&gt;eat&lt;/span&gt; yet?&lt;/div&gt;&lt;script&gt;var spans = $( \"span\" );$( \"p\" ).find( spans ).css( \"color\", \"red\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제의 결과를 보면 맨 아래 div 태그 밑의 span 태그는 변경되지 않았다. p태그의 모든 하위 자식들만 코드를 수행하고 가장 아래의 span 태그는 div 태그의 하위 태그라 적용되지 않았다. 그리고 이 두번째 예제는 인자를 jQuery 객체를 넣었다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;find demo&lt;/title&gt; &lt;style&gt; p &#123; font-size: 20px; width: 200px; color: blue; font-weight: bold; margin: 0 10px; &#125; .hilite &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; When the day is short find that which matters to you or stop believing&lt;/p&gt;&lt;script&gt;var newText = $( \"p\" ).text().split( \" \" ).join( \"&lt;/span&gt; &lt;span&gt;\" );newText = \"&lt;span&gt;\" + newText + \"&lt;/span&gt;\";$( \"p\" ) .html( newText ) .find( \"span\" ) .hover(function() &#123; $( this ).addClass( \"hilite\" ); &#125;, function() &#123; $( this ).removeClass( \"hilite\" ); &#125;) .end() .find( \":contains('t')\" ) .css(&#123; \"font-style\": \"italic\", \"font-weight\": \"bolder\" &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 설명은 즐거움을 찾자 Find Fun!! 님의 설명으로 대신한다..정말 잘하시는것 같다. 사실 여기를 좀 많이 참고해서 정리하고있다.","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"find","slug":"find","permalink":"https://sskim91.github.io/tags/find/"}]},{"title":"jQuery API data 메서드","slug":"jQuery-20180419-jQuery-API-data-메서드","date":"2018-04-19T07:59:32.000Z","updated":"2019-03-23T11:33:49.038Z","comments":true,"path":"2018/04/19/jQuery-20180419-jQuery-API-data-메서드/","link":"","permalink":"https://sskim91.github.io/2018/04/19/jQuery-20180419-jQuery-API-data-메서드/","excerpt":"data() 메서드일치된 요소와 임의의 data를 저장하거나 data의 key값으로 지정한 값을 가져올 수 있다. data() 메서드를 사용하면 모든 유형의 데이터를 DOM 요소에 추가할 수 있다. 12345$( \"body\" ).data( \"foo\", 52 );$( \"body\" ).data( \"bar\", &#123; myType: \"test\", count: 40 &#125; );$( \"body\" ).data( &#123; baz: [ 1, 2, 3 ] &#125; );$( \"body\" ).data( \"foo\" ); // 52$( \"body\" ).data(); // &#123; foo: 52, bar: &#123; myType: \"test\", count: 40 &#125;, baz: [ 1, 2, 3 ] &#125;","text":"data() 메서드일치된 요소와 임의의 data를 저장하거나 data의 key값으로 지정한 값을 가져올 수 있다. data() 메서드를 사용하면 모든 유형의 데이터를 DOM 요소에 추가할 수 있다. 12345$( \"body\" ).data( \"foo\", 52 );$( \"body\" ).data( \"bar\", &#123; myType: \"test\", count: 40 &#125; );$( \"body\" ).data( &#123; baz: [ 1, 2, 3 ] &#125; );$( \"body\" ).data( \"foo\" ); // 52$( \"body\" ).data(); // &#123; foo: 52, bar: &#123; myType: \"test\", count: 40 &#125;, baz: [ 1, 2, 3 ] &#125; 예제div에 data를 저장하고 저장한 값을 가져 온다. 1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;data demo&lt;/title&gt; &lt;style&gt; div &#123; color: blue; &#125; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; The values stored were &lt;span&gt;&lt;/span&gt; and &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;$( \"div\" ).data( \"test\", &#123; first: 16, last: \"pizza!\" &#125; );$( \"span:first\" ).text( $( \"div\" ).data( \"test\" ).first );$( \"span:last\" ).text( $( \"div\" ).data( \"test\" ).last );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML5의 data-로 시작하는 속성이나 data(key, value)로 설정된 jQuery 컬렉션의 첫 번째 요소에 대해 key에 맞는 값을 반환한다. .data( key ) key Type: String 데이터에 저장된 key 값 (이름) .data() This signature does not accept any arguments. data() 메서드를 사용하면 한 번에 하나의 요소에 대해 여러 개의 고유 한 값을 검색하거나 한 세트로 검색 할 수 있습니다. 12alert( $( \"body\" ).data( \"foo\" ) );alert( $( \"body\" ).data() ); 위의 행은 body 요소에 설정된 데이터 값을 경고합니다. 해당 요소에 데이터가 설정되지 않은 경우 undefined가 반환됩니다. 123alert( $( \"body\" ).data( \"foo\" ) ); // undefined$( \"body\" ).data( \"bar\", \"foobar\" );alert( $( \"body\" ).data( \"bar\" ) ); // foobar jQuery 3 버전부터 Dataset API 사양에 맞춘다고 한다. Writing a statement like $( &quot;body&quot; ).data( { &quot;my-name&quot;: &quot;aValue&quot; } ).data(); will return { myName: &quot;aValue&quot; }. HTML5의 data- 속성을 jQuery에서 가져오는 방법 1&lt;div data-role=\"page\" data-last-value=\"43\" data-hidden=\"true\" data-options='&#123;\"name\":\"John\"&#125;'&gt;&lt;/div&gt; jQuery 1234$( \"div\" ).data( \"role\" ) === \"page\";$( \"div\" ).data( \"lastValue\" ) === 43;$( \"div\" ).data( \"hidden\" ) === true;$( \"div\" ).data( \"options\" ).name === \"John\"; 예제요소에 저장된 “blah”라는 key에 대한 값을 가져온다. 첫번째 버튼은 blah 라고 저장된 키에 대한 값을 가지고오고 2번째 3번째는 blah 에 값을 저장한다. 그리고 4번째 버튼은 blah 값을 제거한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;data demo&lt;/title&gt; &lt;style&gt; div &#123; margin: 5px; background: yellow; &#125; button &#123; margin: 5px; font-size: 14px; &#125; p &#123; margin: 5px; color: blue; &#125; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;A div&lt;/div&gt;&lt;button&gt;Get \"blah\" from the div&lt;/button&gt;&lt;button&gt;Set \"blah\" to \"hello\"&lt;/button&gt;&lt;button&gt;Set \"blah\" to 86&lt;/button&gt;&lt;button&gt;Remove \"blah\" from the div&lt;/button&gt;&lt;p&gt;The \"blah\" value of this div is &lt;span&gt;?&lt;/span&gt;&lt;/p&gt;&lt;script&gt;$( \"button\" ).click(function() &#123; var value; switch ( $( \"button\" ).index( this ) ) &#123; case 0 : value = $( \"div\" ).data( \"blah\" ); break; case 1 : $( \"div\" ).data( \"blah\", \"hello\" ); value = \"Stored!\"; break; case 2 : $( \"div\" ).data( \"blah\", 86 ); value = \"Stored!\"; break; case 3 : $( \"div\" ).removeData( \"blah\" ); value = \"Removed!\"; break; &#125; $( \"span\" ).text( \"\" + value );&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"}]},{"title":"jQuery after와 insertAfter의 차이","slug":"jQuery-20180320-jQuery-after와-insertAfter의-차이","date":"2018-03-20T09:53:14.000Z","updated":"2018-06-05T04:53:16.757Z","comments":true,"path":"2018/03/20/jQuery-20180320-jQuery-after와-insertAfter의-차이/","link":"","permalink":"https://sskim91.github.io/2018/03/20/jQuery-20180320-jQuery-after와-insertAfter의-차이/","excerpt":"They are mutual opposites.","text":"They are mutual opposites. ‘after‘ inserts the argument after the selector. ‘insertAfter‘ inserts the selector after the argument. Here is an example of the same thing done with: after 메서드는 인자가 선택자 뒤에 들어간다.1$(\".inner\").after(\"&lt;p&gt;Test&lt;/p&gt;\"); insertAfter 메서드는 선택자 뒤에 인자가 들어온다.1$(&quot;&lt;p&gt;Test&lt;/p&gt;&quot;).insertAfter(&quot;.inner&quot;); insertAfter():1234567891011121314&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt;$( \"&lt;p&gt;Test&lt;/p&gt;\" ).insertAfter( \".inner\" );Each inner &lt;div&gt; element gets this new content:&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;p&gt;Test&lt;/p&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt; &lt;p&gt;Test&lt;/p&gt;&lt;/div&gt; after():1234567891011121314&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt;$( \".inner\" ).after( \"&lt;p&gt;Test&lt;/p&gt;\" );&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;p&gt;Test&lt;/p&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt; &lt;p&gt;Test&lt;/p&gt;&lt;/div&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"}]},{"title":"jQuery API filter 메서드","slug":"jQuery-20180317-jQuery-API-filter-메서드","date":"2018-03-17T14:32:46.000Z","updated":"2019-03-23T11:33:49.038Z","comments":true,"path":"2018/03/17/jQuery-20180317-jQuery-API-filter-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/17/jQuery-20180317-jQuery-API-filter-메서드/","excerpt":"선택된 요소 집합을 필터? 원하는대로 필터링 할 수 있다는 것 같다.","text":"선택된 요소 집합을 필터? 원하는대로 필터링 할 수 있다는 것 같다. DOM 요소 집합을 나타내는 jQuery 객체가 주어지면 .filter () 메서드는 일치하는 요소의 하위 집합에서 새 jQuery 객체를 생성합니다. 우리가 일상생활에서 생각 하는 필터? 의 기능이 프로그래밍과 똑같은 것 같다. 필터링 한다는게 기존에 있던 거를 새로운 것으로 바꾼다? 라는 의미가 있는데 프로그래밍 언어에서도 똑같다. 기존에 jQuery 객체를 filter() 메서드를 통해서 새로운 jQuery 객체를 생성하는 것이다. 간단하게 먼저 살펴보자 12345678&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt; &lt;li&gt;list item 6&lt;/li&gt;&lt;/ul&gt; 아래의 스크립트를 적용 1$( \"li\" ).filter( \":even\" ).css( \"background-color\", \"red\" ); 결과는 :even 이라는 짝수 번째에 li 태그에 빨간색으로 배경색이 칠해진다. list item1, list item 3, list item 5 가 빨간색으로 칠해진다. 왜 짝수번째 라면서 1,3,5 냐고 생각할 수도 있는데 :even이나 :odd 는 index가 0을 기준으로 시작하기 때문이다! Filter Function 사용이 메서드의 인자로 function을 사용하면 선택자가 아닌 함수에 대해 요소를 필터링 할 수 있습니다. 각 요소에 대해 함수가 true (또는 “truthy”값)를 반환하면 요소가 필터링 된 집합에 포함됩니다. 그렇지 않으면 제외됩니다. 123456789&lt;ul&gt; &lt;li&gt;&lt;strong&gt;list&lt;/strong&gt; item 1 - one strong tag&lt;/li&gt; &lt;li&gt;&lt;strong&gt;list&lt;/strong&gt; item &lt;strong&gt;2&lt;/strong&gt; - two &lt;span&gt;strong tags&lt;/span&gt;&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt; &lt;li&gt;list item 6&lt;/li&gt;&lt;/ul&gt; list item을 선택한 다음 그것들의 내용을 기준으로 필터링 할 수 있다. 12345$( \"li\" ) .filter(function( index ) &#123; return $( \"strong\", this ).length === 1; &#125;) .css( \"background-color\", \"red\" ); 이 코드는 정확히 하나의 strong 태그를 포함하므로 첫 번째 목록 항목 만 변경합니다. 위에서 사용된 this 키워드는 리스트(li)를 의미한다. 즉 모든 li들이 this에 한 번씩 해당하게 된다. 인자로 넘겨진 index는 각 li들의 index를 뜻한다. 필터 함수 내에서 이것은 차례대로 각 DOM 요소를 참조합니다. 함수에 전달 된 매개 변수는 jQuery 객체와 일치하는 집합 내의 DOM 요소 색인을 알려줍니다. 또한 함수를 통해 전달 된 인덱스를 활용할 수도 있다.이 인덱스는 일치하는 요소 집합내의 인덱스를 말한다. 인덱스는 0부터 시작 12345$( \"li\" ) .filter(function( index ) &#123; return index % 3 === 2; &#125;) .css( \"background-color\", \"red\" ); 3으로 나눴을 때 나머지가 2인 li들만 배경색이 빨간색으로 변경된다. 예제모든 div 들의 배경색을 바꾸고 클래스가 middle인 div의 테두리를 빨간색으로 바꿔줍니다. 12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;filter demo&lt;/title&gt; &lt;style&gt; div &#123; width: 60px; height: 60px; margin: 5px; float: left; border: 2px white solid; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=\"middle\"&gt;&lt;/div&gt;&lt;div class=\"middle\"&gt;&lt;/div&gt;&lt;div class=\"middle\"&gt;&lt;/div&gt;&lt;div class=\"middle\"&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;$( \"div\" ) .css( \"background\", \"#c8ebcc\" ) .filter( \".middle\" ) .css( \"border-color\", \"red\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제div들의 배경색을 바꾼다. 그리고 index가 1인 경우와 id값이 fourth 인 경우에는 추가적으로 border 속성을 추가한다. 위에서 살펴본 인덱스를 활용한 filter 123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;filter demo&lt;/title&gt; &lt;style&gt; div &#123; width: 60px; height: 60px; margin: 5px; float: left; border: 3px white solid; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"first\"&gt;&lt;/div&gt;&lt;div id=\"second\"&gt;&lt;/div&gt;&lt;div id=\"third\"&gt;&lt;/div&gt;&lt;div id=\"fourth\"&gt;&lt;/div&gt;&lt;div id=\"fifth\"&gt;&lt;/div&gt;&lt;div id=\"sixth\"&gt;&lt;/div&gt;&lt;script&gt;$( \"div\" ) .css( \"background\", \"#b4b0da\" ) .filter(function( index ) &#123; return index === 1 || $( this ).attr( \"id\" ) === \"fourth\"; &#125;) .css( \"border\", \"3px double red\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"filter","slug":"filter","permalink":"https://sskim91.github.io/tags/filter/"}]},{"title":"jQuery API parents 메서드","slug":"jQuery-20180316-jQuery-API-parents-메서드","date":"2018-03-16T04:31:43.000Z","updated":"2019-03-23T11:34:42.230Z","comments":true,"path":"2018/03/16/jQuery-20180316-jQuery-API-parents-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/16/jQuery-20180316-jQuery-API-parents-메서드/","excerpt":"선택자로 검색된 문서 객체의 태그 요소의 상위 요소(부모 요소들)를 반환한다. 부가적으로 반환된 jQuery 객체에 다른 메서드나 속성을 사용할 수 있다.","text":"선택자로 검색된 문서 객체의 태그 요소의 상위 요소(부모 요소들)를 반환한다. 부가적으로 반환된 jQuery 객체에 다른 메서드나 속성을 사용할 수 있다. parents() 함수는 DOM 트리를 구성하는 요소들의 부모들을 찾아서 새로운 jQuery 객체 집합을 구성해 준다. 객체 집합은 추가되는 순서에 따라 인덱스가 부여된다. parent() 와의 차이점은 부모요소 들! 이라는 점이다. parent() 와 parents() 의 차이점은 상위 요소들을 단일로 반환하느냐 아니면 그 이상이냐의 차이가 있다. 바로 간단한 예제로 살펴보자 1234567891011121314151617&lt;ul class=\"level-1\"&gt; &lt;li class=\"item-i\"&gt;I&lt;/li&gt; &lt;li class=\"item-ii\"&gt;II &lt;ul class=\"level-2\"&gt; &lt;li class=\"item-a\"&gt;A&lt;/li&gt; &lt;li class=\"item-b\"&gt;B &lt;ul class=\"level-3\"&gt; &lt;li class=\"item-1\"&gt;1&lt;/li&gt; &lt;li class=\"item-2\"&gt;2&lt;/li&gt; &lt;li class=\"item-3\"&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"item-c\"&gt;C&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"item-iii\"&gt;III&lt;/li&gt;&lt;/ul&gt; 아래의 스크립트를 적용 1$( \"li.item-a\" ).parents().css( \"background-color\", \"red\" ); 스크립트의 결과는 level-2, item II, level-1 목록들을 빨간색으로 바꿔줍니다. (사실 &lt;html&gt; 요소까지 올라갑니다). 선택자를 인자로 주지 않았기 때문에, 모든 부모요소들이 객체로 만들어 집니다. 만약 선택자를 넣으면 그에 맞게 필터되어 결과집합에 포함되게 됩니다. 예제b 요소의 모든 부모요소들을 찾는다. b 요소의 부모요소들을 찾아서 태그명들을 map() 메서드를 사용해서 배열로 바꿔주었다. jQuery객체를 반환하기 때문에 바로 map() 메서드를 체이닝으로 사용할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;parents demo&lt;/title&gt; &lt;style&gt; b, span, p, html body &#123; padding: .5em; border: 1px solid; &#125; b &#123; color: blue; &#125; strong &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p&gt; &lt;span&gt; &lt;b&gt;My parents are: &lt;/b&gt; &lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;script&gt;var parentEls = $( \"b\" ).parents() .map(function() &#123; return this.tagName; &#125;) .get() .join( \", \" );$( \"b\" ).append( \"&lt;strong&gt;\" + parentEls + \"&lt;/strong&gt;\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제클릭된 span의 유일한 div 부모요소의 개수를 카운팅한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;parents demo&lt;/title&gt; &lt;style&gt; p, div, span &#123; margin: 2px; padding: 1px; &#125; div &#123; border: 2px white solid; &#125; span &#123; cursor: pointer; font-size: 12px; &#125; .selected &#123; color: blue; &#125; b &#123; color: red; display: block; font-size: 14px; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; &lt;div&gt; &lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt; &lt;span&gt;Hello Again&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;And Hello Again&lt;/span&gt; &lt;/div&gt; &lt;/p&gt; &lt;b&gt;Click Hellos to toggle their parents.&lt;/b&gt;&lt;script&gt;function showParents() &#123; $( \"div\" ).css( \"border-color\", \"white\" ); var len = $( \"span.selected\" ) .parents( \"div\" ) .css( \"border\", \"2px red solid\" ) .length; $( \"b\" ).text( \"Unique div parents: \" + len );&#125;$( \"span\" ).click(function() &#123; $( this ).toggleClass( \"selected\" ); showParents();&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"parents","slug":"parents","permalink":"https://sskim91.github.io/tags/parents/"}]},{"title":"jQuery API parent 메서드","slug":"jQuery-20180316-jQuery-API-parent-메서드","date":"2018-03-16T04:31:39.000Z","updated":"2019-03-23T11:34:42.230Z","comments":true,"path":"2018/03/16/jQuery-20180316-jQuery-API-parent-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/16/jQuery-20180316-jQuery-API-parent-메서드/","excerpt":"선택자로 검색된 문서 객체의 태그 요소의 상위 요소(부모 요소)를 반환한다. 부가적으로 반환된 jQuery 객체에 다른 메서드나 속성을 사용할 수 있다.","text":"선택자로 검색된 문서 객체의 태그 요소의 상위 요소(부모 요소)를 반환한다. 부가적으로 반환된 jQuery 객체에 다른 메서드나 속성을 사용할 수 있다. parent() 메서드는 DOM 트리에서 요소의 바로 위의 부모(상위)를 탐색하고 일치하는 요소에서 새 jQuery 객체를 생성한다.이 메서드는 DOM 트리에서 한 단계 상위의 요소만 반환하는거를 제외하고는 .parents()메서드와 유사하다. 12$(\"html\").parent(); //상위 문서 객체 1개만 반환$(\"html\").parents();//상위 문서 객체 전부 다 반환 예제p태그 선택자의 상위 요소 div 태그 중에 selected란 클래스가 있는 요소에 css를 적용 123456789101112131415161718&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;parent demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;&lt;div class=\"selected\"&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;/div&gt;&lt;script&gt;$( \"p\" ).parent( \".selected\" ).css( \"background\", \"yellow\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"parent","slug":"parent","permalink":"https://sskim91.github.io/tags/parent/"}]},{"title":"jQuery API appendTo 메서드","slug":"jQuery-20180316-jQuery-API-appendTo-메서드","date":"2018-03-16T04:28:48.000Z","updated":"2019-03-23T11:34:42.230Z","comments":true,"path":"2018/03/16/jQuery-20180316-jQuery-API-appendTo-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/16/jQuery-20180316-jQuery-API-appendTo-메서드/","excerpt":"매개변수로 지정된 내용을 각 요소의 끝에 삽입한다. 매개변수로 넘어간 요소에 마지막 자식 요소를 새로 추가한다.","text":"매개변수로 지정된 내용을 각 요소의 끝에 삽입한다. 매개변수로 넘어간 요소에 마지막 자식 요소를 새로 추가한다. append() 메서드와 동일한 기능을 한다. 다만 차이점은 추가될 컨텐츠와 타겟의 위치가 두 함수의 가장 큰 차이점이다. HTML 12345&lt;h2&gt;Greetings&lt;/h2&gt;&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; 스크립트 - appendTo() 메서드는 추가될 컨텐츠가 앞에 오고 타겟의 위치가 뒤에온다. 1$( \"&lt;p&gt;Test&lt;/p&gt;\" ).appendTo( \".inner\" ); append() 메서드는 추가될 컨텐츠가 뒤에 오고 타겟의 위치가 앞에 1$( \".inner\" ).append( \"&lt;p&gt;Test&lt;/p&gt;\" ); 결과는 다 같다. 1234567891011&lt;h2&gt;Greetings&lt;/h2&gt;&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt; Hello &lt;p&gt;Test&lt;/p&gt; &lt;/div&gt; &lt;div class=\"inner\"&gt; Goodbye &lt;p&gt;Test&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 또한 아래와 같은 방식으로도 추가할 수 있다. 1$( \"h2\" ).appendTo( $( \".container\" ) ); 그랬을 때 결과가 아래와 같이 나온다. 12345&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt; &lt;h2&gt;Greetings&lt;/h2&gt;&lt;/div&gt; 만약 추가할 컨텐츠 요소가 복수개라면, 처음 작업은 이동되고 그 다음에 추가될 때는 그 첫번째 작업에 대한 내용을 복사하여 추가하게 된다. jsfiddle로 확인해보면 된다. 예제id가 foo인 요소에 모든 span 요소들을 추가 123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;appendTo demo&lt;/title&gt; &lt;style&gt; #foo &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span&gt;I have nothing more to say... &lt;/span&gt;&lt;div id=\"foo\"&gt;FOO! &lt;/div&gt;&lt;script&gt;$( \"span\" ).appendTo( \"#foo\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"appendTo","slug":"appendTo","permalink":"https://sskim91.github.io/tags/appendTo/"}]},{"title":"jQuery API append 메서드","slug":"jQuery-20180316-jQuery-API-append-메서드","date":"2018-03-16T04:27:07.000Z","updated":"2019-03-23T11:34:42.231Z","comments":true,"path":"2018/03/16/jQuery-20180316-jQuery-API-append-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/16/jQuery-20180316-jQuery-API-append-메서드/","excerpt":"매개변수로 지정된 내용을 각 요소의 끝에 삽입한다. 매개변수로 넘어간 요소에 마지막 자식 요소를 새로 추가한다.","text":"매개변수로 지정된 내용을 각 요소의 끝에 삽입한다. 매개변수로 넘어간 요소에 마지막 자식 요소를 새로 추가한다. append() 메서드는 지정한 요소를 jQuery 집합(collection)의 각 요소별로 마지막 자식 요소를 추가해주는 함수이다. 만약 첫번째 자식으로 삽입하려면 prepend()메서드를 사용하면 된다. .append () 및 .appendTo () 메서드는 동일한 작업을 수행합니다. 주요 차이점은 구문과 특히 콘텐츠 및 대상의 배치에 있습니다. after() 와 insertAfter() 의 차이와 똑같다. 추가하려는 대상을 앞에 넣느냐 뒤에 넣느냐의 차이이다. 아래와 같은 HTML을 봐보자 12345&lt;h2&gt;Greetings&lt;/h2&gt;&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; append 메서드 실행 1$( \".inner\" ).append( \"&lt;p&gt;Test&lt;/p&gt;\" ); 결과 12345&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt; &lt;h2&gt;Greetings&lt;/h2&gt;&lt;/div&gt; 여기서 appendTo() 메서드였으면 1$( \"&lt;p&gt;Test&lt;/p&gt;\" ).appendTo( \".inner\" ); 이렇게 써줘도 위의 결과랑 똑같이 나온다. 번역기로 돌린 뜻이 저거이다. 대상의 배치의 차이. 앞에 넣느냐 뒤에 넣느냐의 차이이다. 다수의 인자들(Additional Arguments) 컨텐츠를 추가하는 함수로는 .prepend(), .before(), .append() 등이 있으며 인자를 여러개 가질 수 있는 것도 비슷합니다. 인자로 올 수 있는 것들은 DOM 요소들, jQuery 객체들, HTML 문자열들, 그리고 DOM 요소들의 배열들이 있습니다. 12345var $newdiv1 = $('&lt;div id=\"object1\"/&gt;'), newdiv2 = document.createElement('div'), existingdiv1 = document.getElementById('foo');$('body').append($newdiv1, [newdiv2, existingdiv1]); 3가지 방법으로 &lt;div&gt; 를 만들어서 .append() 함수에 다수의 인자로 넘길 수 있습니다. $(&#39;body&#39;).append($newdiv1, newdiv2, existingdiv1)과 같은 방법으로 말이죠. 예제모든 p 태그에 HTML로 마지막 자식요소를 추가 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;append demo&lt;/title&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;script&gt;$( \"p\" ).append( \"&lt;strong&gt;Hello&lt;/strong&gt;\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 모든 p 태그에 요소를 마지막 자식요소를 추가 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;append demo&lt;/title&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;script&gt;$( \"p\" ).append( document.createTextNode( \"Hello\" ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 모든 p 태그에 jQuery 객체 (DOM 요소 배열도 마찬가지) 마지막 자식요소를 추가 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;append demo&lt;/title&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;strong&gt;Hello world!!!&lt;/strong&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;script&gt;$( \"p\" ).append( $( \"strong\" ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"append","slug":"append","permalink":"https://sskim91.github.io/tags/append/"}]},{"title":"인수(Argument)와 매개변수(Parameter)의 차이","slug":"Web-Developer-20180315-인수-Argument-와-매개변수-Parameter-의-차이","date":"2018-03-15T07:57:35.000Z","updated":"2018-05-09T07:27:01.262Z","comments":true,"path":"2018/03/15/Web-Developer-20180315-인수-Argument-와-매개변수-Parameter-의-차이/","link":"","permalink":"https://sskim91.github.io/2018/03/15/Web-Developer-20180315-인수-Argument-와-매개변수-Parameter-의-차이/","excerpt":"인자값 (Argument)이라고도 부르고 인수라고도 부르는 것과 매개변수 (Parameter), 파라미터라고 부르는 것 들의 차이점","text":"인자값 (Argument)이라고도 부르고 인수라고도 부르는 것과 매개변수 (Parameter), 파라미터라고 부르는 것 들의 차이점 내가 남에게 얘기할 때도 인수, 매개변수를 같은 의미로서 그냥 내 입에 맞는대로 불렀는데 의미가 전혀 다른 용어들 이었다. 검색해서 알아보았으니 이제는 헷갈리지 말고 사용하자 매개변수(Parameter)란 파라미터를 한글로 번역하면 매개변수란 뜻이다. 즉 함수를 정의 할 때 외부로부터 받아들이는 임의의 값을 의미 12345function 함수(aaa, bbb)&#123; return aaa+bbb;&#125;//여기에서 aaa,bbb가 파라미터라고 할 수 있다.//함수의 정의에서 사용되는 변수를 파라미터라고 한다. 그렇다면 인수(Argument)는? 함수를 호출할 때 사용되는 값 들을 인수라고 한다. 예컨대 위의 함수를 호출한다고 하면 12345함수(3,4);/**여기에서 3,4 의 값이 인수(Argument)이다. 아규먼트파라미터의 값으로 아규먼트 3과 4를 대입하였다. 라는 의미가 성립**/ 개발서적을 읽을 때 용어에 대해서 헷갈릴 수 있으니 정리","categories":[{"name":"Web","slug":"Web","permalink":"https://sskim91.github.io/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://sskim91.github.io/tags/Web/"}]},{"title":"HTML5 Web Storage","slug":"Web-Developer-20180315-HTML5-Web-Storage","date":"2018-03-15T07:55:33.000Z","updated":"2018-05-10T01:22:44.507Z","comments":true,"path":"2018/03/15/Web-Developer-20180315-HTML5-Web-Storage/","link":"","permalink":"https://sskim91.github.io/2018/03/15/Web-Developer-20180315-HTML5-Web-Storage/","excerpt":"소스를 살펴보고 있는 도중에 자바스크립트 부분에서 localStorage와 sessionStorage가 보였다.","text":"소스를 살펴보고 있는 도중에 자바스크립트 부분에서 localStorage와 sessionStorage가 보였다. 이게 뭔가 살펴보니까 HTML5에 있는 Web Storage라는 기술이었다. 모질라 developer 사이트에서는 HTML5 Web Storage를 이렇게 설명하고 있다. 브라우저에서 쿠키를 사용하는 것 보다 훨씬 직관적으로 데이터를 저장할 수 있다고 한다. 실제로 Web Storage(이하 웹 저장소)를 사용하면 JSON 형식으로도 저장할 수 있고 기존의 쿠키와 달리 저장 용량도 더 크고 정보가 서버로 전송되지 않기 때문에 트래픽 비용에서도 이점이 있다고 한다. HTML 웹 저장소는 클라이언트에 데이터를 저장하기 위해 두 가지 객체를 제공한다. window.localStorage - 만료 날짜가 없는 데이터를 저장한다. window.sessionStorage - 하나의 세션에 대해 데이터를 저장한다. (브라우저 탭을 닫으면 데이터가 사라진다.) 웹 저장소를 사용하기 이전에 localStorage 및 sessionStorage 의 브라우저에 대한 지원 여부를 확인할 필요가 있다. 12345if (typeof(Storage) !== \"undefined\") &#123; // Code for localStorage/sessionStorage.&#125; else &#123; // Sorry! No Web Storage support..&#125; localStorage ObjectlocalStorage 객체는 쿠키와는 다르게 만료 날짜가 없는 데이터를 저장한다. 이 데이터는 브라우저를 종료하지 않는 한 삭제되지 않는다. 다음 날 또는 다음 주 몇 년 동안 사용할 수 있다. 1234// StorelocalStorage.setItem(\"lastname\", \"Smith\");// Retrievedocument.getElementById(\"result\").innerHTML = localStorage.getItem(\"lastname\"); 설명 key/value 형식을 가지는 localStorage를 생성한다. (여기에서 key는 “lastname”, value는 “Smith”) lastname이라는 값을 검색해여 id가 result인 요소에 값을 넣는다. localStorage에서 “lastname”이라는 키에 해당하는 값을 삭제하고 싶으면 아래와 같이 하면된다. 1localStorage.removeItem(\"lastname\"); name/value의 쌍은 항상 string 형식으로 저장된다. 저장할 때 항상 string 형식으로 변환해서 저장해야 한다. 아래의 예제는 사용자가 버튼을 클릭 한 횟수를 계산한다. 이 코드에서 문자열 값은 숫자형으로 변환된다. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;function clickCounter() &#123; if(typeof(Storage) !== \"undefined\") &#123; if (localStorage.clickcount) &#123; localStorage.clickcount = Number(localStorage.clickcount)+1; &#125; else &#123; localStorage.clickcount = 1; &#125; document.getElementById(\"result\").innerHTML = \"You have clicked the button \" + localStorage.clickcount + \" time(s).\"; &#125; else &#123; document.getElementById(\"result\").innerHTML = \"Sorry, your browser does not support web storage...\"; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;button onclick=\"clickCounter()\" type=\"button\"&gt;Click me!&lt;/button&gt;&lt;/p&gt;&lt;div id=\"result\"&gt;&lt;/div&gt;&lt;p&gt;Click the button to see the counter increase.&lt;/p&gt;&lt;p&gt;Close the browser tab (or window), and try again, and the counter will continue to count (is not reset).&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; sessionStorage ObjectsessionStorage 객체는 하나의 session에 대해서만 데이터를 저장한다는 점만 제외하고는 localStorage 객체와 같다. 이 데이터는 사용자가 특정 브라우저 탭을 종료하면 삭제된다. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;function clickCounter() &#123; if(typeof(Storage) !== \"undefined\") &#123; if (sessionStorage.clickcount) &#123; sessionStorage.clickcount = Number(sessionStorage.clickcount)+1; &#125; else &#123; sessionStorage.clickcount = 1; &#125; document.getElementById(\"result\").innerHTML = \"You have clicked the button \" + sessionStorage.clickcount + \" time(s) in this session.\"; &#125; else &#123; document.getElementById(\"result\").innerHTML = \"Sorry, your browser does not support web storage...\"; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;button onclick=\"clickCounter()\" type=\"button\"&gt;Click me!&lt;/button&gt;&lt;/p&gt;&lt;div id=\"result\"&gt;&lt;/div&gt;&lt;p&gt;Click the button to see the counter increase.&lt;/p&gt;&lt;p&gt;Close the browser tab (or window), and try again, and the counter is reset.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 얼핏 보면 위의 localStorage의 예제와 같아 보이지만 다른 점은 localStorage는 탭을 닫았다가 다시 실행해도 clickcount가 유지되지만 sessionStorage는 브라우저의 탭을 닫았다가 실행하면 데이터가 삭제되고 처음부터 clickcount가 시작된다. 출처 w3schools HTML5 Web Storage 도움 되는 사이트 Web Storage HTML5 튜토리얼 Web Storage","categories":[{"name":"Web","slug":"Web","permalink":"https://sskim91.github.io/categories/Web/"},{"name":"HTML","slug":"Web/HTML","permalink":"https://sskim91.github.io/categories/Web/HTML/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://sskim91.github.io/tags/HTML5/"},{"name":"Web-Storage","slug":"Web-Storage","permalink":"https://sskim91.github.io/tags/Web-Storage/"}]},{"title":"jQuery API 살펴보기 insertBefore 메서드","slug":"jQuery-20180314-jQuery-API-insertBefore-메서드","date":"2018-03-14T08:05:25.000Z","updated":"2019-03-23T11:38:37.927Z","comments":true,"path":"2018/03/14/jQuery-20180314-jQuery-API-insertBefore-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/14/jQuery-20180314-jQuery-API-insertBefore-메서드/","excerpt":"조건에 일치되는 target 요소 앞에 추가될 내용(요소)을 삽입한다.","text":"조건에 일치되는 target 요소 앞에 추가될 내용(요소)을 삽입한다. before() 메서드와 insertBefore()메서드는 동일한 기능을 수행한다. 중요한 차이점은 요소에 들어갈 내용과 대상의 위치 차이이다. 이것 또한 after()와 insertAfter() 와 똑같은 말이다. 들어갈 내용(컨텐츠)가 앞에 들어가야 되는게 insertBefore() 뒤에 들어가야되는게 before() 또 똑같은 예제를 보면 안다. HTML 12345&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; 스크립트 1$( \"&lt;p&gt;Test&lt;/p&gt;\" ).insertBefore( \".inner\" ); 결과 - inner 클래스를 가진 요소의 앞 요소에 컨텐츠가 추가되었다. 1234567&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;p&gt;Test&lt;/p&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;p&gt;Test&lt;/p&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; 예제id가 foo인 요소 앞에 p 태그를 추가한다. before를 사용하면 $(“#foo”).before(“p”); 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;insertBefore demo&lt;/title&gt; &lt;style&gt; #foo &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"foo\"&gt;FOO!&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;script&gt;$( \"p\" ).insertBefore( \"#foo\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"insertBefore","slug":"insertBefore","permalink":"https://sskim91.github.io/tags/insertBefore/"}]},{"title":"jQuery API 살펴보기 before 메서드","slug":"jQuery-20180314-jQuery-API-before-메서드","date":"2018-03-14T08:05:14.000Z","updated":"2019-03-23T11:38:37.927Z","comments":true,"path":"2018/03/14/jQuery-20180314-jQuery-API-before-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/14/jQuery-20180314-jQuery-API-before-메서드/","excerpt":"조건에 일치되는 target 요소 앞에 추가될 내용(요소)을 삽입한다.","text":"조건에 일치되는 target 요소 앞에 추가될 내용(요소)을 삽입한다. before() 메서드와 insertBefore() 의 차이 before() - $(target).before(&#39;내용 contentToBeInserted&#39;); insertBefore() - $(&#39;내용 contentToBeInserted&#39;).insertBefore(target); 예제를 보면 더 잘 알게 된다. HTML 12345&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; 스크립트 1$( \".inner\" ).before( \"&lt;p&gt;Test&lt;/p&gt;\" ); 결과 1234567&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;p&gt;Test&lt;/p&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;p&gt;Test&lt;/p&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; 추가 인자들 ( Additional Arguments )추가될 인자를 사용하는 방법은 .prepend(), .after(), .before() 함수들에 아래와 같은 방법으로 동일하게 적용할 수 있습니다. 인자는 DOM elements, jQuery objects, HTML strings, 그리고 DOM element 배열들을 포함합니다. 예를 들어, 두 개의 &lt;div&gt;를 새로 만들어 추가하려면 아래와 같이 하면 됩니다. 1234var $newdiv1 = $('&lt;div id=\"object1\"/&gt;'), newdiv2 = document.createElement('div'), existingdiv1 = document.getElementById('foo'); $('p').first().before($newdiv1, [newdiv2, existingdiv1]); 추가할 수 있는 인자수는 제한이 없습니다. 또한, 위의 방법 말고 인자를 쭈욱 나열하는 방법도 있는데 위와 아래는 같은 결과를 보여줍니다. 1$('p').first().before($newdiv1, newdiv2, existingdiv1) 예제모든 p 태그 앞에 특정 요소를 추가 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;before demo&lt;/title&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; is what I said...&lt;/p&gt;&lt;script&gt;$( \"p\" ).before( \"&lt;b&gt;Hello&lt;/b&gt;\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 모든 p 태그 앞에 DOM element를 추가 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;before demo&lt;/title&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; is what I said...&lt;/p&gt;&lt;script&gt;$( \"p\" ).before( document.createTextNode( \"Hello\" ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 모든 p 태그 앞에 jQuery object (또는 DOM elements 배열)를 추가 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;before demo&lt;/title&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; is what I said...&lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;script&gt;$( \"p\" ).before( $( \"b\" ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"before","slug":"before","permalink":"https://sskim91.github.io/tags/before/"}]},{"title":"jQuery API 살펴보기 insertAfter 메서드","slug":"jQuery-20180313-jQuery-API-insertAfter-메서드","date":"2018-03-13T09:11:35.000Z","updated":"2019-03-23T11:38:37.927Z","comments":true,"path":"2018/03/13/jQuery-20180313-jQuery-API-insertAfter-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/13/jQuery-20180313-jQuery-API-insertAfter-메서드/","excerpt":"조건에 일치되는 target 요소 뒤에 추가될 내용(요소)를 삽입한다.","text":"조건에 일치되는 target 요소 뒤에 추가될 내용(요소)를 삽입한다. ‘after’는 선택자 다음에 인수를 삽입합니다. ‘insertAfter’는 인수 뒤에 선택기를 삽입합니다. A.after(B)라면 A 뒤에 B를 추가하는 것이고 A.insertAfter(B)는 B 뒤에 A를 추가하는 겁니다. .after () 및 .insertAfter () 메서드는 동일한 작업을 수행합니다. 주요 차이점은 구문과 특히 콘텐츠 및 대상의 배치에 있습니다. 아래의 HTML은 after() 메서드를 설명할 때 사용한 HTML과 똑같다. 그럼 어떤 부분에서 다른지 살펴보자. 12345&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; 스크립트 1$( \"&lt;p&gt;Test&lt;/p&gt;\" ).insertAfter( \".inner\" ); 눈치를 챘는지는 모르겠지만 () 안에 인수의 내용이 뒤바뀌었다. after() 메서드는 삽입할 대상이 뒤에 가있지만 insertAfter() 메서드는 삽입할 대상이 앞에 먼저 나와있다. 나머지는 기능이 거의 같은 것 같다. after() 메서드일때 1$( \".inner\" ).after( \"&lt;p&gt;Test&lt;/p&gt;\" ); 예제id=”foo”를 p 태그 뒤에 삽입한다. after를 사용할 경우 $(“#foo”).after(“p”) 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;insertAfter demo&lt;/title&gt; &lt;style&gt; #foo &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; is what I said... &lt;/p&gt;&lt;div id=\"foo\"&gt;FOO!&lt;/div&gt;&lt;script&gt;$( \"p\" ).insertAfter( \"#foo\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"insertAfter","slug":"insertAfter","permalink":"https://sskim91.github.io/tags/insertAfter/"}]},{"title":"jQuery API 살펴보기 after 메서드","slug":"jQuery-20180313-jQuery-API-after-메서드","date":"2018-03-13T09:11:08.000Z","updated":"2019-03-23T11:38:37.927Z","comments":true,"path":"2018/03/13/jQuery-20180313-jQuery-API-after-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/13/jQuery-20180313-jQuery-API-after-메서드/","excerpt":"어떤 요소 뒤에 새로운 요소를 추가한다.","text":"어떤 요소 뒤에 새로운 요소를 추가한다. .after () 및 .insertAfter () 메서드는 동일한 작업을 수행합니다. 주요 차이점은 구문과 특히 콘텐츠 및 대상의 배치에 있습니다. .after ()를 사용하면 삽입 할 내용은 메서드의 인수 인 $ (target) .after (contentToBeInserted)에서 가져옵니다. 반면에 .insertAfter ()를 사용하면 내용 앞에 메서드가 삽입되고 대상 다음에 삽입되고 .insertAfter () 메서드의 인수로 전달됩니다. $ (contentToBeInserted) .insertAfter (target). 아래와 같은 HTML 코드를 봐보자. 12345&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt; jQuery after 메서드 사용 : 한번에 여러 요소의 뒤에 내용이나 요소를 삽입할 수 있다. 1$( \".inner\" ).after( \"&lt;p&gt;Test&lt;/p&gt;\" ); 각 div 밑에 새로운 컨텐츠가 하나씩 생겼다. 1234567&lt;div class=\"container\"&gt; &lt;h2&gt;Greetings&lt;/h2&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;p&gt;Test&lt;/p&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt; &lt;p&gt;Test&lt;/p&gt;&lt;/div&gt; DOM 에 있는 특정 요소를 선택해서 다른 요소 뒤쪽에 위치 시킬수도 있다. 1$( \".container\" ).after( $( \"h2\" ) ); 기존의 h2 태그 요소가 아래로 이동되었다. 만약 하나 이상의 요소가 있으면 첫번째는 이동되어 처리되고 그 다음 부터는 복사되어 처리된다. 12345&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt;Hello&lt;/div&gt; &lt;div class=\"inner\"&gt;Goodbye&lt;/div&gt;&lt;/div&gt;&lt;h2&gt;Greetings&lt;/h2&gt; 추가 인자들(Additional Arguments)여러개의 인자를 넘겨받아 새로운 요소를 추가하는 함수들은 .prepend(), .before(), .after() 와 같이 비슷한 함수들이 있습니다. 인자로는 DOM elements, jQuery objects, HTML 문자열들, 그리고 DOM elements로 구성된 배열 등이 올 수 있습니다. 예를 들어, 새로운 2개의 &lt;div&gt;와 이미 존재하는 &lt;div&gt;를 첫번째 p요소 다음에 추가하는 내용입니다. 12345var $newdiv1 = $('&lt;div id=\"object1\"/&gt;'), newdiv2 = document.createElement('div'), existingdiv1 = document.getElementById('foo');$('p').first().after($newdiv1, [newdiv2, existingdiv1]); .after() 함수는 여러개의 인자를 가질 수 있기 때문에, 세가지 방법을 통해 &lt;div&gt; 를 만들어서 붙여넣을 수 있습니다. $(&#39;p&#39;).first().after($newdiv1, newdiv2, existingdiv1) 이런 것처럼 말이죠. 예제p 태그 뒤에 HTML 문자열을 사용해 추가한다. 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;after demo&lt;/title&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;script&gt;$( \"p\" ).after( \"&lt;b&gt;Hello&lt;/b&gt;\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; p 태그 뒤에 텍스트 노드를 만들어 추가한다. 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;after demo&lt;/title&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;script&gt;$( \"p\" ).after( document.createTextNode( \"Hello\" ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; p 태그 뒤에 jQuery 객체를 사용하여 추가한다. 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;after demo&lt;/title&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;script&gt;$( \"p\" ).after( $( \"b\" ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"after","slug":"after","permalink":"https://sskim91.github.io/tags/after/"}]},{"title":"jQuery API 살펴보기 Children 메서드","slug":"jQuery-20180312-jQuery-API-children-메서드","date":"2018-03-12T03:06:10.000Z","updated":"2019-03-23T11:42:10.933Z","comments":true,"path":"2018/03/12/jQuery-20180312-jQuery-API-children-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/12/jQuery-20180312-jQuery-API-children-메서드/","excerpt":"선택자와 일치하는 요소들 각각의 자식 요소들을 반환한다.","text":"선택자와 일치하는 요소들 각각의 자식 요소들을 반환한다. children() 메서드의 인자로 넣은 선택자에 해당하는 DOM 요소를 찾아서 jQuery 객체로 반환시켜준다. children()와 find() 메서드의 다른점은 둘다 하위 요소들을 검색하는 것은 같은데 children() 메서드는 DOM 트리 레벨에서 바로 아래 하위 단계의 요소만 반환하고 find() 메서드는 모든 하위 요소들을 찾는데에서 차이가 있다. 그리고 children() 메서드는 text node들은 반환하지 않는다. text node 까지 얻으려면 .contents() 메서드를 사용하면 된다. 예제를 통해서 알아보자. 예제1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;children demo&lt;/title&gt; &lt;style&gt; body &#123; font-size: 16px; font-weight: bolder; &#125; div &#123; width: 130px; height: 82px; margin: 10px; float: left; border: 1px solid blue; padding: 4px; &#125; #container &#123; width: auto; height: 105px; margin: 0; float: none; border: none; &#125; .hilite &#123; border-color: red; &#125; #results &#123; display: block; color: red; &#125; p, span, em, a, b, button &#123; border: 1px solid transparent; &#125; p &#123; margin: 10px; &#125; span &#123; color: blue; &#125; input &#123; width: 100px; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"container\"&gt; &lt;div&gt; &lt;p&gt;This &lt;span&gt;is the &lt;em&gt;way&lt;/em&gt; we&lt;/span&gt; write &lt;em&gt;the&lt;/em&gt; demo,&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=\"#\"&gt;&lt;b&gt;w&lt;/b&gt;rit&lt;b&gt;e&lt;/b&gt;&lt;/a&gt; the &lt;span&gt;demo,&lt;/span&gt; &lt;button&gt;write the&lt;/button&gt; demo, &lt;/div&gt; &lt;div&gt; This &lt;span&gt;the way we &lt;em&gt;write&lt;/em&gt; the &lt;em&gt;demo&lt;/em&gt; so&lt;/span&gt; &lt;input type=\"text\" value=\"early\"&gt; in &lt;/div&gt; &lt;p&gt; &lt;span&gt;t&lt;/span&gt;he &lt;span&gt;m&lt;/span&gt;orning. &lt;span id=\"results\"&gt;Found &lt;span&gt;0&lt;/span&gt; children in &lt;span&gt;TAG&lt;/span&gt;.&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;script&gt;$( \"#container\" ).click(function ( event ) &#123; $( \"*\" ).removeClass( \"hilite\" ); var kids = $( event.target ).children(); var len = kids.addClass( \"hilite\" ).length; $( \"#results span:first\" ).text( len ); $( \"#results span:last\" ).text( event.target.tagName ); event.preventDefault();&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이 예제에서 event 는 클릭된 객체(요소)이다. 음 그러니까 클릭 된 요소 의 자식을 kids에 담았다. 위의 소스에 대해서 잘 이해가 안가서 이해를 하고 넘어가려고 크롬 개발자 도구까지 실행하면서 분석해보았다. 첫번째 div 부분을 클릭했을 때 kids의 값은 div 태그의 children() 이 저장된다. div 태그의 children은 p 태그 하나이다. 실제로 클릭해보면 div children가 1개 있다고 한다. 여기에서 find 메서드와 차이가 있는 것인데 만약 find 메서드였으면 p태그를 포함해서 그 아래 span 과 em 태그까지 찾았을 것이다. 12345678&lt;div&gt; &lt;p&gt;This &lt;span&gt;is the &lt;em&gt;way&lt;/em&gt; we&lt;/span&gt; write &lt;em&gt;the&lt;/em&gt; demo,&lt;/p&gt;&lt;/div&gt;&lt;!--첫번째 div 부분을 클릭했을 때 kids의 값은 div 태그의 children() 이 저장된다. div 태그의 children은 p 태그 하나이다. 실제로 클릭해보면 div children가 1개 있다고 한다. 여기에서 find 메서드와 차이가 있는 것인데 만약 find 메서드였으면 p태그를 포함해서 그 아래 span 과 em 태그까지 찾았을 것이다.--&gt; div 요소의 자식 요소들에 빨간 2줄짜리 밑줄을 그려준다. 12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;children demo&lt;/title&gt; &lt;style&gt; body &#123; font-size: 16px; font-weight: bolder; &#125; span &#123; color: blue; &#125; p &#123; margin: 5px 0; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello (this is a paragraph)&lt;/p&gt;&lt;div&gt;&lt;span&gt;Hello Again (this span is a child of the a div)&lt;/span&gt;&lt;/div&gt;&lt;p&gt;And &lt;span&gt;Again&lt;/span&gt; (in another paragraph)&lt;/p&gt;&lt;div&gt;And One Last &lt;span&gt;Time&lt;/span&gt; (most text directly in a div)&lt;/div&gt;&lt;script&gt;$( \"div\" ).children().css( \"border-bottom\", \"3px double red\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;children demo&lt;/title&gt; &lt;style&gt; body &#123; font-size: 16px; font-weight: bolder; &#125; p &#123; margin: 5px 0; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;p class=\"selected\"&gt;Hello Again&lt;/p&gt; &lt;div class=\"selected\"&gt;And Again&lt;/div&gt; &lt;p&gt;And One Last Time&lt;/p&gt;&lt;/div&gt;&lt;script&gt;$( \"div\" ).children( \".selected\" ).css( \"color\", \"blue\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"children","slug":"children","permalink":"https://sskim91.github.io/tags/children/"}]},{"title":"jQuery API 살펴보기 jQuery isPlainObject 메서드","slug":"jQuery-20180311-jQuery-API-jQuery-isPlainObject-메서드","date":"2018-03-11T14:47:30.000Z","updated":"2019-03-23T11:42:10.933Z","comments":true,"path":"2018/03/11/jQuery-20180311-jQuery-API-jQuery-isPlainObject-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/11/jQuery-20180311-jQuery-API-jQuery-isPlainObject-메서드/","excerpt":"확인하려는 객체가 자바스크립트 객체인지 확인합니다. ( “{}” 또는 “new Object”로 만들어진 객체)","text":"확인하려는 객체가 자바스크립트 객체인지 확인합니다. ( “{}” 또는 “new Object”로 만들어진 객체) Host object(개발자가 작성한 스크립트에 의한 객체)는 브라우져 별로 객체를 다루는 상황이 달라 몇가지 어려운 점을 가지고 있습니다. 이런 이유로, 브라우져별로 $.isPlainObject() 사용을 확인해 보는게 좋습니다. 예를 들어 document.location 객체를 $.isPlainObject() 함수로 테스트 해보면 1console.log( $.isPlainObject( document.location ) ); IE8에서는 invalid pointer exception이 발생합니다. 이런 이유로 오래된 버전의 브라우저에서 사용시에는 주의해서 사용해야 합니다. 예제12jQuery.isPlainObject(&#123;&#125;) // truejQuery.isPlainObject( \"test\" ) // false","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"isPlainObject","slug":"isPlainObject","permalink":"https://sskim91.github.io/tags/isPlainObject/"}]},{"title":"jQuery API 살펴보기 jQuery isEmptyObject 메서드","slug":"jQuery-20180311-jQuery-API-jQuery-isEmptyObject-메서드","date":"2018-03-11T14:47:20.000Z","updated":"2019-03-23T11:42:10.933Z","comments":true,"path":"2018/03/11/jQuery-20180311-jQuery-API-jQuery-isEmptyObject-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/11/jQuery-20180311-jQuery-API-jQuery-isEmptyObject-메서드/","excerpt":"객체(object) 값이 비어있는지 검사합니다.","text":"객체(object) 값이 비어있는지 검사합니다. jQuery 1.4에서부터 이 메서드는 객체 자체의 속성과 프로토 타입에서 상속된 속성까지 모두 확인한다. 다른 유형의 객체 (DOM 요소나, 기본 string/number)는 브라우저마다 일관된 결과를 제공하지 않을 수 있으므로 argument 값은 언제나 Javascript Object(자바스크립트 객체) 이어야 한다. 객체가 자바스크립트 객체인지 확인하려면 $.isPlainObject()를 사용하면 된다.! 예제12jQuery.isEmptyObject(&#123;&#125;); // truejQuery.isEmptyObject(&#123; foo: \"bar\" &#125;); // false","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"isEmptyObject","slug":"isEmptyObject","permalink":"https://sskim91.github.io/tags/isEmptyObject/"}]},{"title":"jQuery API 살펴보기 jQuery isArray 메서드","slug":"jQuery-20180310-jQuery-API-jQuery-isArray-메서드","date":"2018-03-10T14:01:35.000Z","updated":"2019-03-23T11:42:10.933Z","comments":true,"path":"2018/03/10/jQuery-20180310-jQuery-API-jQuery-isArray-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/10/jQuery-20180310-jQuery-API-jQuery-isArray-메서드/","excerpt":"인수로 들어온 값이 배열인지 확인해 주는 메서드","text":"인수로 들어온 값이 배열인지 확인해 주는 메서드 $.isArray() 메서드는 인수로 넘어온 값이 배열인지 아닌지를 확인해서 배열이면 true 값을 아니면 false 값을 return 한다. 즉 boolean 값을 리턴한다. 파라미터가 배열인지 아닌지 확인한다. 1234567891011121314151617&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery.isArray demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;Is [] an Array? &lt;b&gt;&lt;/b&gt;&lt;script&gt;$( \"b\" ).append( \"\" + $.isArray([]) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"isArray","slug":"isArray","permalink":"https://sskim91.github.io/tags/isArray/"}]},{"title":"jQuery API 살펴보기 jQuery inArray 메서드","slug":"jQuery-20180310-jQuery-API-jQuery-inArray-메서드","date":"2018-03-10T14:01:29.000Z","updated":"2019-03-23T11:42:10.933Z","comments":true,"path":"2018/03/10/jQuery-20180310-jQuery-API-jQuery-inArray-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/10/jQuery-20180310-jQuery-API-jQuery-inArray-메서드/","excerpt":"배열 내에 지정된 값을 찾아서 인덱스를 반환한다. (찾지 못했을 경우 -1을 반환한다.)","text":"배열 내에 지정된 값을 찾아서 인덱스를 반환한다. (찾지 못했을 경우 -1을 반환한다.) 이 $.inArray() 메서드는 자바스크립트의 .indexOf() 메서드와 유사하다. 지정된 값을 찾지못하면 -1을 반환한다 그리고 배열의 첫번째 요소가 지정한 값과 일치 할 경우 0을 반환한다. 그냥 자바스크립트의 indexOf() 과 같다고 생각하면 될 것 같다. 1$.inArray( 5 + 5, [ \"8\", \"9\", \"10\", 10 + \"\" ] ); 위의 식에서는 -1을 리턴한다. 이 문자열 배열에서는 숫자를 검색하는데 숫자가 없기 때문에 -1을 반환한다. 사용법1$.inArray(value, array[,fromIndex]); value 에는 찾을 값이 들어가고 array에는 배열이 들어간다. fromIndex 부분은 시작할 인덱스의 위치를 지정해줄 수 있다. (기본 값은 0이다.) 예제예제의 결과를 살펴보면 마지막에 -1을 반환한다. “Pete”라는 값이 있지만 인덱스를 검색할때 2번째 부터 시작했기 때문에 -1이 반환된다. 123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery.inArray demo&lt;/title&gt; &lt;style&gt; div &#123; color: blue; &#125; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;\"John\" found at &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;4 found at &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;\"Karl\" not found, so &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;\"Pete\" is in the array, but not at or after index 2, so &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var arr = [ 4, \"Pete\", 8, \"John\" ];var $spans = $( \"span\" );$spans.eq( 0 ).text( jQuery.inArray( \"John\", arr ) );$spans.eq( 1 ).text( jQuery.inArray( 4, arr ) );$spans.eq( 2 ).text( jQuery.inArray( \"Karl\", arr ) );$spans.eq( 3 ).text( jQuery.inArray( \"Pete\", arr, 2 ) );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"inArray","slug":"inArray","permalink":"https://sskim91.github.io/tags/inArray/"}]},{"title":"jQuery API 살펴보기 jQuery.each() 메서드","slug":"jQuery-20180309-jQuery-API-jQuery-each-메서드","date":"2018-03-09T12:50:04.000Z","updated":"2019-03-23T11:42:10.933Z","comments":true,"path":"2018/03/09/jQuery-20180309-jQuery-API-jQuery-each-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/09/jQuery-20180309-jQuery-API-jQuery-each-메서드/","excerpt":"반복 함수이다. 자바스크립트에서 foreach 와 같은 기능을 하는 메서드이다.","text":"반복 함수이다. 자바스크립트에서 foreach 와 같은 기능을 하는 메서드이다. 일반적으로 배열 또는 객체의 데이터를 반복적으로 반복하는 함수이다. 자바스크립트의 foreach 와의 조금 다른점은 인수의 위치가 반대인 것 빼고는 나머지는 같다. 1234//자바스크립트[].foreach(callback(item, index)&#123;&#125;);//jQuery[].each(callback(index, item))&#123;&#125;; $.each() 메서드는 $(‘selector’).each() 와는 다르다. $.each() 함수는 객체인지 배열에 관계없이 모든 컬렉션을 반복하는데 사용할 수 있다. 배열의 경우 콜백은 배열 인덱스와 해당 배열 값을 전달 받는다. 값들은 this 키워드를 통해서 접근할 수도 있지만 단순한 문자열이나 숫자도 자바스크립트는 항상 이 값을 Object(객체)로 wrapping 한다. 예제배열 12345678$.each([ 52, 97 ], function( index, value ) &#123; console.log( index + \": \" + value );&#125;);/***** 결과0: 521: 97*****/ 객체를 사용해서 each() 메서드를 사용할 경우 key-value 구조로 콜백에 전달된다. 123456789101112var obj = &#123; \"flammable\": \"inflammable\", \"duh\": \"no duh\"&#125;;$.each( obj, function( key, value ) &#123; alert( key + \": \" + value );&#125;);/****flammable: inflammableduh: no duh*****/ $.each() 반복을 멈추려면 return false를 코드상에 작성하면 된다. 배열에서의 $.each() 메서드에서 “three” 부분에서 반복을 멈추는 부분이 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery.each demo&lt;/title&gt; &lt;style&gt; div &#123; color: blue; &#125; div#five &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"one\"&gt;&lt;/div&gt;&lt;div id=\"two\"&gt;&lt;/div&gt;&lt;div id=\"three\"&gt;&lt;/div&gt;&lt;div id=\"four\"&gt;&lt;/div&gt;&lt;div id=\"five\"&gt;&lt;/div&gt;&lt;script&gt;var arr = [ \"one\", \"two\", \"three\", \"four\", \"five\" ];var obj = &#123; one: 1, two: 2, three: 3, four: 4, five: 5 &#125;;jQuery.each( arr, function( i, val ) &#123; $( \"#\" + val ).text( \"Mine is \" + val + \".\" ); // Will stop running after \"three\" return ( val !== \"three\" );&#125;);jQuery.each( obj, function( i, val ) &#123; $( \"#\" + i ).append( document.createTextNode( \" - \" + val ) );&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"each","slug":"each","permalink":"https://sskim91.github.io/tags/each/"}]},{"title":"jQuery API 살펴보기 each() 메서드","slug":"jQuery-20180309-jQuery-API-each-메서드","date":"2018-03-09T12:49:51.000Z","updated":"2019-03-23T11:47:38.733Z","comments":true,"path":"2018/03/09/jQuery-20180309-jQuery-API-each-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/09/jQuery-20180309-jQuery-API-each-메서드/","excerpt":".each() 메서드는 DOM 문서 객체의 선택된 요소를 지정한 수 만큼 반복시켜주는 메서드이다.","text":".each() 메서드는 DOM 문서 객체의 선택된 요소를 지정한 수 만큼 반복시켜주는 메서드이다. 선택된 HTML의 요소를 반복을 돌면서 jQuery 객체를 DOM에 생성한다. 음..즉 그냥 자바스크립트에서 for-each 같은 반복문인데 이 .each() 메서드는 HTML DOM 구조를 가지고 반복문을 돌린다. 이때 callback 안에서 this라는 키워드를 사용할 수 있는데 이때 this는 호출된 선택자의 this값이다. 또한 이 .each() 메서드는 jQuery.each() 메서드와는 또 다르다. 전자는 DOM 구조에 대한 반복을 실행할 수 있고 후자는 배열이나 XML 객체 등을 반복하는데 사용된다. 예제간단한 예제를 보면서 확인해보자. 아래와 같은 html이 있다고 했을 때 1234&lt;ul&gt; &lt;li&gt;foo&lt;/li&gt; &lt;li&gt;bar&lt;/li&gt;&lt;/ul&gt; li라는 선택자를 넣고 each() 메서드를 실행한다. 여기서 index는 0부터 시작한다. li가 있는 개수 만큼 반복된다. 또한 여기서 this는 반복을 수행하면서 현재 반복되고 있는 어떤 DOM 구조에 추가적인 작업을 할 수 가 있다. 123$( \"li\" ).each(function( index ) &#123; console.log( index + \": \" + $( this ).text() );&#125;); 위의 결과는 아래와 같이 나온다. 그리고 반복을 멈추고 싶을 때는 return false를 추가하면 된다. 120: foo1: bar 클릭에 따라서 div안에 text 색깔이 바뀌는 예제 123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;each demo&lt;/title&gt; &lt;style&gt; div &#123; color: red; text-align: center; cursor: pointer; font-weight: bolder; width: 300px; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;Click here&lt;/div&gt;&lt;div&gt;to iterate through&lt;/div&gt;&lt;div&gt;these divs.&lt;/div&gt;&lt;script&gt;$( document.body ).click(function() &#123; $( \"div\" ).each(function( i ) &#123; if ( this.style.color !== \"blue\" ) &#123; this.style.color = \"blue\"; &#125; else &#123; this.style.color = \"\"; &#125; &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 일반 DOM 요소 대신 jQuery 객체에 접근하기 위해서는 $(this)를 사용해서 접근한다. 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;each demo&lt;/title&gt; &lt;style&gt; ul &#123; font-size: 18px; margin: 0; &#125; span &#123; color: blue; text-decoration: underline; cursor: pointer; &#125; .example &#123; font-style: italic; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;To do list: &lt;span&gt;(click here to change)&lt;/span&gt;&lt;ul&gt; &lt;li&gt;Eat&lt;/li&gt; &lt;li&gt;Sleep&lt;/li&gt; &lt;li&gt;Be merry&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;$( \"span\" ).click(function() &#123; $( \"li\" ).each(function() &#123; $( this ).toggleClass( \"example\" ); &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위에서 얘기했던 반복을 멈추고싶을 때 return false 를 쓰는 예제 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;each demo&lt;/title&gt; &lt;style&gt; div &#123; width: 40px; height: 40px; margin: 5px; float: left; border: 2px blue solid; text-align: center; &#125; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;Change colors&lt;/button&gt;&lt;span&gt;&lt;/span&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div id=\"stop\"&gt;Stop here&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;$( \"button\" ).click(function() &#123; $( \"div\" ).each(function( index, element ) &#123; // element == this $( element ).css( \"backgroundColor\", \"yellow\" ); if ( $( this ).is( \"#stop\" ) ) &#123; $( \"span\" ).text( \"Stopped at div index #\" + index ); return false; &#125; &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"}]},{"title":"jQuery API 살펴보기 prev() 메서드","slug":"jQuery-20180308-jQuery-API-prev-메서드","date":"2018-03-08T02:30:25.000Z","updated":"2019-03-23T11:47:38.717Z","comments":true,"path":"2018/03/08/jQuery-20180308-jQuery-API-prev-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/08/jQuery-20180308-jQuery-API-prev-메서드/","excerpt":"prev() 메서드는 HTML 내에서 지정한 요소의 이전 요소를 반환하는 메서드이다.","text":"prev() 메서드는 HTML 내에서 지정한 요소의 이전 요소를 반환하는 메서드이다. next() 메서드는 다음 요소를 반환하고 prev() 메서드는 이전 요소를 반환하는 것만 차이가 있다. prev () 메소드는 DOM 요소 집합을 나타내는 jQuery 객체가 주어지면 DOM 트리에서 이러한 각 요소의 이전 요소를 검색하고 일치하는 요소에서 새 jQuery 객체를 생성한다. 앞의 인접한 형제가 아닌 모든 선행 형제 요소를 선택하려면 .prevAll () 메서드를 사용하면 된다. 예제123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;prev demo&lt;/title&gt; &lt;style&gt; div &#123; width: 40px; height: 40px; margin: 10px; float: left; border: 2px blue solid; padding: 2px; &#125; span &#123; font-size: 14px; &#125; p &#123; clear: left; margin: 10px; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;span&gt;has child&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div id=\"start\"&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;button&gt;Go to Prev&lt;/button&gt;&lt;/p&gt;&lt;script&gt;var $curr = $( \"#start\" );$curr.css( \"background\", \"#f99\" );$( \"button\" ).click(function() &#123; $curr = $curr.prev(); $( \"div\" ).css( \"background\", \"\" ); $curr.css( \"background\", \"#f99\" );&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $curr 라는 변수에 id 값이 start인 div태그를 저장한다. 버튼을 클릭하면 현재 div의 이전 요소의 jQuery 객체를 반환한다. &lt;&lt; prev() 메서드를 실행함 그리고 div 태그의 css의 background를 없애고 $curr의 저장된 div태그에 background를 칠한다. 12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;prev demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt;&lt;p class=\"selected\"&gt;Hello Again&lt;/p&gt;&lt;p&gt;And Again&lt;/p&gt;&lt;script&gt;$( \"p\" ).prev( \".selected\" ).css( \"background\", \"yellow\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; prev()의 메서드에 인자로 들어간 .selected 라는 클래스를 찾는다. 이때 .selected가 없으면 jQuery는 빈 객체를 반환하고 있으면 jQuery 객체가 생성된다. 그래서 메서드 체이닝으로 .css() 메서드를 실행할 수 있는 것이다.","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"prev","slug":"prev","permalink":"https://sskim91.github.io/tags/prev/"}]},{"title":"jQuery API 살펴보기 next() 메서드","slug":"jQuery-20180308-jQuery-API-next-메서드","date":"2018-03-08T02:30:17.000Z","updated":"2019-03-23T11:47:38.717Z","comments":true,"path":"2018/03/08/jQuery-20180308-jQuery-API-next-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/08/jQuery-20180308-jQuery-API-next-메서드/","excerpt":"next() 메서드는 HTML 내에서 지정한 요소의 다음 요소를 반환하는 메서드이다.","text":"next() 메서드는 HTML 내에서 지정한 요소의 다음 요소를 반환하는 메서드이다. DOM 요소 집합을 나타내는 jQuery 객체가 주어지면 .next () 메서드를 사용하면 DOM 트리에서 이러한 요소의 바로 다음 형제를 검색하고 일치하는 요소에서 새 jQuery 객체를 생성 할 수 있습니다. 같은 말만 반복하고 있는것 같은데 역시 예제를 통해서 알아보자! 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;next demo&lt;/title&gt; &lt;style&gt; span &#123; color: blue; font-weight: bold; &#125; button &#123; width: 100px; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;button disabled=\"disabled\"&gt;First&lt;/button&gt; - &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;button&gt;Second&lt;/button&gt; - &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;button disabled=\"disabled\"&gt;Third&lt;/button&gt; - &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;$( \"button[disabled]\" ).next().text( \"this button is disabled\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위의 예제를 실행하면 비 활성화된 버튼 요소를 찾아서 그 요소의 다음 노드에 text를 작성한다. 위의 소스는 비 활성화된 버튼이 2개가 있는데 그 2개의 요소 다음 형제 요소는 span 태그이다. 그러니 결과를 보면 span 태그 안에 this button is disabled 라는 텍스트가 들어가있는 것을 확인할 수 있다. 다음 예제를 살펴보자 12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;next demo&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;p class=\"selected\"&gt;Hello Again&lt;/p&gt;&lt;div&gt;&lt;span&gt;And Again&lt;/span&gt;&lt;/div&gt;&lt;script&gt;$( \"p\" ).next( \".selected\" ).css( \"background\", \"yellow\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 예제의 스크립트 부분을 보면 p 태그에 대해서 next() 메서드를 사용한 후에 그 다음 형제 요소 중에 selected 라는 클래스 속성을 가지고 있는 요소만 css를 변경한다.","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"next","slug":"next","permalink":"https://sskim91.github.io/tags/next/"}]},{"title":"jQuery API 살펴보기 change() 메서드","slug":"jQuery-20180308-jQuery-API-change-메서드","date":"2018-03-08T02:29:46.000Z","updated":"2019-03-11T05:32:55.272Z","comments":true,"path":"2018/03/08/jQuery-20180308-jQuery-API-change-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/08/jQuery-20180308-jQuery-API-change-메서드/","excerpt":"선택된 요소의 값을 변경해주는 jQuery change() 메서드이다.","text":"선택된 요소의 값을 변경해주는 jQuery change() 메서드이다. change 이벤트는 값이 변경되면 요소로 보내집니다. 이 이벤트는 input 요소, textarea 상자 및 select 요소로 제한된다. 선택 상자, 체크 상자 및 라디오 단추의 경우 사용자가 마우스로 선택하면 이벤트가 즉시 발생하지만 다른 요소 유형의 경우 요소가 포커스를 잃을 때까지 이벤트가 연기됩니다. 예제12345678910&lt;form&gt; &lt;input class=\"target\" type=\"text\" value=\"Field 1\"&gt; &lt;select class=\"target\"&gt; &lt;option value=\"option1\" selected=\"selected\"&gt;Option 1&lt;/option&gt; &lt;option value=\"option2\"&gt;Option 2&lt;/option&gt; &lt;/select&gt;&lt;/form&gt;&lt;div id=\"other\"&gt; Trigger the handler&lt;/div&gt; 이벤트 핸들러는 text input 과 select box 에 바인딩 될 수 있다. 123$( \".target\" ).change(function() &#123; alert( \"Handler for .change() called.\" );&#125;); select option 중에 두번 째 옵션을 드롭다운에서 선택하면 alert 창이 나타난다. text field 에 입력 값을 바꾸고 아무데나 클릭해도 change() 메서드가 실행되어서 alert 창이 나타난다. 그러나 아무 작업도 하지 않고 그냥 input field 가 focus를 잃으면 이벤트가 트리거 되지 않는다. 그럴 때 이벤트를 수동으로 트리거하려면 인수 없이 .change()를 적용하면 된다. 123$( \"#other\" ).click(function() &#123; $( \".target\" ).change();&#125;); 실제로 테스트 해보면 이해할 수 있다. alert이 두번 실행되는 이유는 .target 클래스가 2개 있고 2번 이벤트를 타기 때문이다. 아래 예제는 select 된 option을 가져와서 div에 text로 나타낸다. 1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;change demo&lt;/title&gt; &lt;style&gt; div &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;select name=\"sweets\" multiple=\"multiple\"&gt; &lt;option&gt;Chocolate&lt;/option&gt; &lt;option selected=\"selected\"&gt;Candy&lt;/option&gt; &lt;option&gt;Taffy&lt;/option&gt; &lt;option selected=\"selected\"&gt;Caramel&lt;/option&gt; &lt;option&gt;Fudge&lt;/option&gt; &lt;option&gt;Cookie&lt;/option&gt;&lt;/select&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;$( \"select\" ) .change(function () &#123; var str = \"\"; $( \"select option:selected\" ).each(function() &#123; str += $( this ).text() + \" \"; &#125;); $( \"div\" ).text( str ); &#125;) .change();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"change","slug":"change","permalink":"https://sskim91.github.io/tags/change/"}]},{"title":"jQuery UI 살펴보기 Datepicker","slug":"jQueryUI-20180306-jQuery-UI-살펴보기-Datepicker","date":"2018-03-06T05:28:16.000Z","updated":"2018-05-10T01:25:01.109Z","comments":true,"path":"2018/03/06/jQueryUI-20180306-jQuery-UI-살펴보기-Datepicker/","link":"","permalink":"https://sskim91.github.io/2018/03/06/jQueryUI-20180306-jQuery-UI-살펴보기-Datepicker/","excerpt":"jQuery는 자바스크립트 라이브러리로서 웹 화면에서의 DOM 제어가 수월하기 때문에 웹 개발의 생산성을 향상 시킬 수 있다.","text":"jQuery는 자바스크립트 라이브러리로서 웹 화면에서의 DOM 제어가 수월하기 때문에 웹 개발의 생산성을 향상 시킬 수 있다. 거기에서 파생되서 나온 jQuery UI(User Interface)는 jQuery 기반의 GUI 라이브러리 이다. jQuery UI 를 사용하면 마우스를 활용해서 드래그 및 드롭다운의 상호작용 효과를 만들 수 있고 버튼이나 체크박스, 데이트픽커 같은 사용자가 이용할 때 보기도 좋고 쓰기도 좋은 위젯들과 여러가지 효과 그리고 유틸리티를 쉽게 사용할 수 있다. 그 중에서도 Datepicker는 날짜 선택을 편하게 해줄 수 있는 위젯으로서 그 활용도가 굉장히 높다. 어느 사이트나 날짜를 선택하는데 있어서 이 Datepicker 위젯을 많이 사용하는 것 같다. 그래서 이번에 한번 이 위젯의 API를 한번 정리해보려고한다. 정리라고 해봐야 공식 문서에 있는것을 한번 써보고 올리는 것 밖에 안된다. 그래도 해보자. 공식 홈페이지 가보면 정말 많은 기능이 있다. 사용법일단 jQuery UI를 사용하려면 기존의 jQuery 라이브러리와 jQuery UI 의 css를 적용해 주어야 사용할 수 있다. 1234&lt;!-- 3가지 라이브러리 추가 --&gt;&lt;link rel=\"stylesheet\" href=\"//code.jquery.com/ui/1.12.1/themes/smoothness/jquery-ui.css\"&gt;&lt;script src=\"//code.jquery.com/jquery-1.12.4.js\"&gt;&lt;/script&gt;&lt;script src=\"//code.jquery.com/ui/1.12.1/jquery-ui.js\"&gt;&lt;/script&gt; 간단하게 Datepicker 위젯의 모습을 살펴보면 이렇게 해주면 된다. 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;datepicker demo&lt;/title&gt; &lt;!-- 3가지 라이브러리 추가 --&gt; &lt;link rel=\"stylesheet\" href=\"//code.jquery.com/ui/1.12.1/themes/smoothness/jquery-ui.css\"&gt; &lt;script src=\"//code.jquery.com/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script src=\"//code.jquery.com/ui/1.12.1/jquery-ui.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"datepicker\"&gt;&lt;/div&gt;&lt;script&gt;$( \"#datepicker\" ).datepicker();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위처럼 간단하게 달력 형태의 모습을 띄는 위젯이 생성되었다. 그런데 이렇게만 놔두면 쓸모가 없으니 여러가지 option과 event가 존재한다. 지금부터 그것을 하나씩 정리해보자. Default Options옵션을 정리하기 전에 Global Options를 적용해 줄 수가 있다. datepicker를 사용하면서 기본옵션을 아래와 같이 해줄수가 있다. 123456$.datepicker.setDefaults(&#123; showOn: \"both\", buttonImageOnly: true, buttonImage: \"calendar.gif\", buttonText: \"Calendar\"&#125;); 여기에서는 설명하지 않지만 Datepicker를 한글화로 해서 쓸 수가 있다. 그건 검색해서 알아보자. Options altfield 옵션 datepiker에서 선택한 날짜로 업데이트 하기 위한 옵션이다 altformat 옵션 위의 altfield에서 선택한 날짜를 업데이트 할 때 format을 변경하기 위한 옵션이다. 음 설명이 왜이렇게 어렵지.. 설명보다 코드로 확인하는게 아마 더 이해하기 쉬울 것 같다. 아래 altField에 선택된 옵션 값이 들어가는데 format을 지정해주면 해당 format으로 수정되어서 값이 들어간다. 1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;datepicker demo&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"//code.jquery.com/ui/1.12.1/themes/smoothness/jquery-ui.css\"&gt; &lt;script src=\"//code.jquery.com/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script src=\"//code.jquery.com/ui/1.12.1/jquery-ui.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;input type=\"text\" id=\"inputDate\" placeholder=\"datepicker선택\"&gt;&lt;/div&gt;&lt;input type=\"text\" id=\"alt_date\" placeholder=\"altField 수정될 내용\"&gt;&lt;script&gt;$( \"#inputDate\" ).datepicker(&#123; altField: \"#alt_date\", altFormat: \"yy-mm-dd\"&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 앞으로는 전체 코드말고 script 부분만 올린다. appendText 옵션 이 옵션은 선택된 datepicker 날짜 값 필드 다음에 추가로 텍스트를 넣는다 예를 들어서 사용자에게 날짜를 입력받을 때 꼭 특수한 형식으로 입력하라고 할때 사용하기 좋다. 123456&lt;script&gt;$( \"#inputDate\" ).datepicker(&#123; dateFormat: \"yy-mm-dd\", appendText: \"yyyy-mm-dd 형식으로 입력\"&#125;);&lt;/script&gt; autoSize 옵션 true로 설정하면 입력 필드의 크기가 자동으로 조정된다. 크기는 형식에 맞는 크기로 조정되는 것 같다. 12345&lt;script&gt;$( \"#inputDate\" ).datepicker(&#123; autoSize: true&#125;);&lt;/script&gt; buttonImage 옵션 “showOn” 옵션이 “button” 또는 “both”로 설정된 경우 datepicker를 표시하는데 사용할 이미지의 URL 옵션 12345&lt;script&gt;$( \"#inputDate\" ).datepicker(&#123; buttonImage: \"/images/datepicker.gif\"&#125;);&lt;/script&gt; buttonImageOnly 옵션 이 옵션은 buttonImage 옵션이 설정된 경우에만 사용된다. 12345&lt;script&gt;$( \"#inputDate\" ).datepicker(&#123; buttonImageOnly: true&#125;);&lt;/script&gt; buttonText 옵션 이 옵션 또한 “showOn” 옵션이 button이나 both 로 설정된 경우에만 사용가능하고 버튼에 텍스트를 표시하는 옵션이다. 12345&lt;script&gt;$( \"#inputDate\" ).datepicker(&#123; buttonText: \"Choose\"&#125;);&lt;/script&gt; changeMonth 옵션 드롭다운 박스로 월을 변경할 수 있게 해주는 옵션 default 값은 false이고 true 값을 지정해주면 생성된다. 12345&lt;script&gt;$( \"#inputDate\" ).datepicker(&#123; changeMonth: true&#125;);&lt;/script&gt; 확인해보면 월을 변경할 수 있게 셀렉트 박스(드롭다운)가 생성 되었다. changeYear 옵션 changeMonth 옵션과 똑같다. year을 변경할 수 있게 드롭다운으로 보여준다. default 값은 false이고 true 값을 지정해주면 된다. 12345&lt;script&gt;$( \"#inputDate\" ).datepicker(&#123; changeYear: true&#125;);&lt;/script&gt; closeText 옵션 datepicker를 닫기 버튼의 Text를 수정하는 옵션이다. default로는 “Done” 이라고 되어있는데 옵션을 통해 수정할 수 있다. 이 옵션을 사용하기 전에 showButtonPanel 이라는 옵션을 true 값으로 설정해 주어야한다. 이 옵션은 버튼 패널을 보이게한다. 123456&lt;script&gt;$( \"#inputDate\" ).datepicker(&#123; showButtonPanel: true, closeText: \"Close\"&#125;);&lt;/script&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQueryUI","slug":"정리/jQueryUI","permalink":"https://sskim91.github.io/categories/정리/jQueryUI/"}],"tags":[{"name":"jQueryUI","slug":"jQueryUI","permalink":"https://sskim91.github.io/tags/jQueryUI/"}]},{"title":"jQuery API 살펴보기 text 메서드","slug":"jQuery-20180305-jQuery-API-text-메서드","date":"2018-03-05T00:08:16.000Z","updated":"2019-03-11T05:31:29.674Z","comments":true,"path":"2018/03/05/jQuery-20180305-jQuery-API-text-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/05/jQuery-20180305-jQuery-API-text-메서드/","excerpt":"기존의 자바스크립트에서 문서 객체의 textContent 속성과 관련된 jQuery 메서드이다.","text":"기존의 자바스크립트에서 문서 객체의 textContent 속성과 관련된 jQuery 메서드이다. html() 메서드와의 차이점은 text() 메서드는 HTML 태그를 인식하지 못한다. 또 html() 메서드는 요소 집합의 첫 번째 요소만 가지고 오는 것에 비해 text() 메서드는 선택자로 선택 한 모든 문서 객체의 글자를 출력한다. 사용법html() 메서드와 달리 text() 메서드는 HTML 문서와 XML 문서에서도 사용이 가능하다. 메서드 형태 12$('selector').text(value);$('selector').text(function(index, text)&#123;&#125;); 예제text() 메서드는 HTML 태그를 인식하지 않는다. 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;text demo&lt;/title&gt; &lt;style&gt; p &#123; color: blue; margin: 8px; &#125; b &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;Test&lt;/b&gt; Paragraph.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt;var str = $( \"p:first\" ).text();$( \"p:last\" ).html( str );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567&lt;div class=\"demo-container\"&gt; &lt;div class=\"demo-box\"&gt;Demonstration Box&lt;/div&gt; &lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list &lt;strong&gt;item&lt;/strong&gt; 2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 위와 같은 코드에 아래의 jQuery 메서드를 실행 1$( \"div.demo-container\" ).text( \"&lt;p&gt;This is a test.&lt;/p&gt;\" ); 결과 123&lt;div class=\"demo-container\"&gt; &amp;lt;p&amp;gt;This is a test.&amp;lt;/p&amp;gt;&lt;/div&gt; 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;text demo&lt;/title&gt; &lt;style&gt; p &#123; color: blue; margin: 8px; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Test Paragraph.&lt;/p&gt;&lt;script&gt;$( \"p\" ).text( \"&lt;b&gt;Some&lt;/b&gt; new text.\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"text","slug":"text","permalink":"https://sskim91.github.io/tags/text/"}]},{"title":"jQuery API 살펴보기 html 메서드","slug":"jQuery-20180305-jQuery-API-html-메서드","date":"2018-03-05T00:08:09.000Z","updated":"2019-03-11T05:30:45.964Z","comments":true,"path":"2018/03/05/jQuery-20180305-jQuery-API-html-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/05/jQuery-20180305-jQuery-API-html-메서드/","excerpt":"기존의 자바스크립트에서의 문서 객체의 innerHTML 속성과 관련된 jQuery 메서드이다.","text":"기존의 자바스크립트에서의 문서 객체의 innerHTML 속성과 관련된 jQuery 메서드이다. jQuery의 text() 메서드와 헷갈릴 수 있는데 차이점은 html() 메서드는 HTML 태그를 인식 하는 점에서 차이가 있다. html() 메서드는 일치하는 요소 집합의 첫 번째 요소에 대한 HTML 내용을 가져온다. 선택된 요소의 매치가 여러 개가 있을 때는 제일 첫 번째에 해당하는 요소가 선택되어서 반환된다. 사용법메소드 형태 12$('selector').html(value);$('selector').html(function(index, html)&#123;&#125;); 이 메소드는 XML 문서에서는 사용할 수 없다. 123&lt;div class=\"demo-container\"&gt; &lt;div class=\"demo-box\"&gt;Demonstration Box&lt;/div&gt;&lt;/div&gt; 위와 같은 HTML이 있을 때 아래와 같은 html() 메서드를 사용하면 1$(\"div.demo-container\").html(); 결과는 아래와 같이 반환된다. 1&lt;div class=\"demo-box\"&gt;Demonstration Box&lt;/div&gt; 예제html 메서드는 매개변수로 입력하고자 하는 HTML 문자열을 입력한다. 중요한건 html() 메서드는 HTML 태그를 인식하여 문자열을 삽입한다. 해당 결과를 보면 h1 태그를 인식한 결과가 나온다. 123456789101112131415161718&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;html demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;$( \"div\" ).html( \"&lt;h1&gt;$().html() Method&lt;/h1&gt;\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 함수를 매개변수로 입력하는 html() 메서드 div의 개수 만큼 header 옆의 인덱스 숫자가 증가하는 것을 볼 수 있다. 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;html demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;$( \"div\" ).html(function(index)&#123; return '&lt;h1&gt;Header-'+index+'&lt;/h1&gt;';&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"html","slug":"html","permalink":"https://sskim91.github.io/tags/html/"}]},{"title":"jQuery API 살펴보기 addClass 메서드","slug":"jQuery-20180304-jQuery-API-addClass-메서드","date":"2018-03-04T06:40:04.000Z","updated":"2018-05-10T01:22:15.976Z","comments":true,"path":"2018/03/04/jQuery-20180304-jQuery-API-addClass-메서드/","link":"","permalink":"https://sskim91.github.io/2018/03/04/jQuery-20180304-jQuery-API-addClass-메서드/","excerpt":"addClass() 메서드는 HTML 태그에 클래스 속성을 추가할때 사용하는 메서드이다.","text":"addClass() 메서드는 HTML 태그에 클래스 속성을 추가할때 사용하는 메서드이다. 1$('selector').addClass('className'); 두 개 이상의 클래스 속성을 추가할 때는 아래와 같이 사용해 주면 된다. 스페이스로 클래스명을 구분한다. 1$('selector').addClass('myClass yourClass'); addClass() 메서드는 removeClass() 랑 자주 사용된다. 기존에 있던 클래스 속성을 지우고 새롭게 클래스 속성을 추가할때 사용된다. 1$('selector').removeClass('myClass noClass').addClass('yourClass'); jQuery 1.4 이후부터는 addClass() 메서드에 함수를 매개변수로 입력할 수도 있다. 123$('selector').addClass(function(index)&#123; return 'class'+index;&#125;) 예제p 태그 선택자 마지막에 클래스 속성을 추가 12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;addClass demo&lt;/title&gt; &lt;style&gt; p &#123; margin: 8px; font-size: 16px; &#125; .selected &#123; color: blue; &#125; .highlight &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;and&lt;/p&gt;&lt;p&gt;Goodbye&lt;/p&gt;&lt;script&gt;$( \"p\" ).last().addClass( \"selected\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; p 태그 선택자 마지막에 두 개의 클래스 속성을 추가 12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;addClass demo&lt;/title&gt; &lt;style&gt; p &#123; margin: 8px; font-size: 16px; &#125; .selected &#123; color: red; &#125; .highlight &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;and&lt;/p&gt;&lt;p&gt;Goodbye&lt;/p&gt;&lt;script&gt;$( \"p:last\" ).addClass( \"selected highlight\" );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; addClass() 메서드에 함수를 매개변수로 입력한 예제 매개변수로 입력하는 함수는 index 매개변수를 갖는다. 선택자로 선택한 문서 객체에 차례대로 속성을 지정할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;addClass demo&lt;/title&gt; &lt;style&gt; div &#123; background: white; &#125; .red &#123; background: red; &#125; .red.green &#123; background: green; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;This div should be white&lt;/div&gt; &lt;div class=\"red\"&gt;This div will be green because it now has the \"green\" and \"red\" classes. It would be red if the addClass function failed.&lt;/div&gt; &lt;div&gt;This div should be white&lt;/div&gt; &lt;p&gt;There are zero green divs&lt;/p&gt;&lt;script&gt;$( \"div\" ).addClass(function( index, currentClass ) &#123; var addedClass; if ( currentClass === \"red\" ) &#123; addedClass = \"green\"; $( \"p\" ).text( \"There is one green div\" ); &#125; return addedClass;&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"jQuery","slug":"정리/jQuery","permalink":"https://sskim91.github.io/categories/정리/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sskim91.github.io/tags/jQuery/"},{"name":"addClass","slug":"addClass","permalink":"https://sskim91.github.io/tags/addClass/"}]},{"title":"Javascript userAgent 속성-브라우저 정보 확인하기","slug":"JavaScript-20180227-Javascript-userAgent-속성-브라우저-정보-확인하기","date":"2018-02-27T02:23:26.000Z","updated":"2018-05-10T06:55:27.966Z","comments":true,"path":"2018/02/27/JavaScript-20180227-Javascript-userAgent-속성-브라우저-정보-확인하기/","link":"","permalink":"https://sskim91.github.io/2018/02/27/JavaScript-20180227-Javascript-userAgent-속성-브라우저-정보-확인하기/","excerpt":"DOM 객체 Navigator의 userAgent라는 속성이 있다.","text":"DOM 객체 Navigator의 userAgent라는 속성이 있다. 이 속성은 브라우저의 정보를 표시해주는 속성이다. 현재 사용하고 있는 브라우저의 정보를 확인할 수 있다. 모바일도 각각의 브라우저가 있다. userAgent 속성은 브라우저에서 서버로 보낸 사용자 에이전트 헤더의 값을 반환한다. 반환 된 값에는 브라우저의 이름, 버전 및 플랫폼에 대한 정보가 들어 있다. (이 프로퍼티는 읽기 전용이다.) 문법1navigator.userAgent 예제123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div id=\"demo\"&gt;&lt;/div&gt;&lt;script&gt;var txt = \"\";txt += \"&lt;p&gt;Browser CodeName: \" + navigator.appCodeName + \"&lt;/p&gt;\";txt += \"&lt;p&gt;Browser Name: \" + navigator.appName + \"&lt;/p&gt;\";txt += \"&lt;p&gt;Browser Version: \" + navigator.appVersion + \"&lt;/p&gt;\";txt += \"&lt;p&gt;Cookies Enabled: \" + navigator.cookieEnabled + \"&lt;/p&gt;\";txt += \"&lt;p&gt;Browser Language: \" + navigator.language + \"&lt;/p&gt;\";txt += \"&lt;p&gt;Browser Online: \" + navigator.onLine + \"&lt;/p&gt;\";txt += \"&lt;p&gt;Platform: \" + navigator.platform + \"&lt;/p&gt;\";txt += \"&lt;p&gt;User-agent header: \" + navigator.userAgent + \"&lt;/p&gt;\";document.getElementById(\"demo\").innerHTML = txt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;//결과Browser CodeName: MozillaBrowser Name: NetscapeBrowser Version: 5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36Cookies Enabled: trueBrowser Language: koBrowser Online: truePlatform: MacIntelUser-agent header: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36 인터넷에서 바로 userAgent를 확인할 수 있는 사이트도 있다. User Agent String.Com Javascript 로 userAgent를 가져와서 간단하게 모바일 디바이스를 구분하는 함수 소스12345678910111213141516171819202122// 모바일 에이전트 구분var isMobile = &#123; Android: function () &#123; return navigator.userAgent.match(/Android/i) == null ? false : true; &#125;, BlackBerry: function () &#123; return navigator.userAgent.match(/BlackBerry/i) == null ? false : true; &#125;, IOS: function () &#123; return navigator.userAgent.match(/iPhone|iPad|iPod/i) == null ? false : true; &#125;, Opera: function () &#123; return navigator.userAgent.match(/Opera Mini/i) == null ? false : true; &#125;, Windows: function () &#123; return navigator.userAgent.match(/IEMobile/i) == null ? false : true; &#125;, any: function () &#123; return (isMobile.Android() || isMobile.BlackBerry() || isMobile.IOS() || isMobile.Opera() || isMobile.Windows()); &#125;&#125;;//출처: http://cofs.tistory.com/214 [CofS] 사용방법12345678910111213141516if(isMobile.any())&#123; if(isMobile.Android())&#123; &#125;else if(isMobile.IOS())&#123; &#125;else if(isMobile.BlackBerry())&#123; &#125;else if(isMobile.Opera())&#123; &#125;else if(isMobile.Windows())&#123; &#125;&#125;//1# : any 함수로 모바일인지 아닌지를 구분한다.//2# ~ : 각 모바일 디바이스를 구분한다.//출처: http://cofs.tistory.com/214 [CofS] 참조 http://cofs.tistory.com/214 [CofS]","categories":[{"name":"Programming","slug":"Programming","permalink":"https://sskim91.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://sskim91.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sskim91.github.io/tags/JavaScript/"},{"name":"userAgent","slug":"userAgent","permalink":"https://sskim91.github.io/tags/userAgent/"}]},{"title":"Java 엑셀 파일 읽고 쓰는 라이브러리 Apache POI","slug":"Java-20180226-Java-엑셀-파일-읽고-쓰는-라이브러리-apache-poi","date":"2018-02-26T06:17:25.000Z","updated":"2018-05-10T01:22:29.120Z","comments":true,"path":"2018/02/26/Java-20180226-Java-엑셀-파일-읽고-쓰는-라이브러리-apache-poi/","link":"","permalink":"https://sskim91.github.io/2018/02/26/Java-20180226-Java-엑셀-파일-읽고-쓰는-라이브러리-apache-poi/","excerpt":"앞으로 자바에서 쓰이는 라이브러리들을 알아가는 대로 예제를 보면서 작성할 예정이다. 그 첫번째로 apache 오픈소스 라이브러리인 apache POI 이다.","text":"앞으로 자바에서 쓰이는 라이브러리들을 알아가는 대로 예제를 보면서 작성할 예정이다. 그 첫번째로 apache 오픈소스 라이브러리인 apache POI 이다. 아파치 POI(Apache POI)는 아파치 소프트웨어 재단에서 만든 라이브러리로서 마이크로소프트 오피스 파일 포맷을 순수 자바) 언어로서 읽고 쓰는 기능을 제공한다. 주로 워드, 엑셀, 파워포인트와 파일을 지원하며 최근의 오피스 포맷인 Office Open XML File Formats [1] (OOXML, 즉 xml 기반의 .docx, .xlsx, *.pptx 등) 이나 아웃룩, 비지오, 퍼블리셔 등으로 지원 파일 포맷을 늘려가고 있다. 위키백과 공식사이트 는 여기이고 들어가보면 왼쪽 메뉴에 Component API 를 들어가서 Quick Guide 부분을 살펴보면 굉장히 설명이 잘 되어있다. 필요한 부분을 찾아서 사용하면 될 것 같다. 물론 영어긴 한데 천천히 하면 되지 않을까…싶다. 예제를 작성하기 전에 라이브러리를 다운 받아야 한다. 다운로드 주소 위 화면에서 2개가 있는데 첫번째 꺼는 엑셀 2007 이전 버전일 때 사용하고 다음 꺼는 엑셀 2007버전 이후를 read나 write할때 사용된다. (2007 버전 전후로 확장자가 xls, xlsx 로 바뀌었다. xlsx가 2007 이후 버전이다.) 직접 프로젝트에 라이브러리를 다운 받아서 넣어줘도되고 maven을 사용한다면 dependency를 추가해주면 된다. 나는 maven에 추가했다. 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 엑셀 Write바로 예제를 들어가보면 첫번째로 특정위치에 엑셀 파일을 생성하는 예제이다. 웹으로 생각해보면 어떤 그리드 화면에서 데이터를 입력하고 저장을 누르거나 완료 버튼을 누르면 엑셀 파일로 저장되는 부분이라고 생각(?)하면 될 것 같다. 응용해서 만들어보면 될 것 같다. 이 예제에서는 Java코드에서 바로 데이터를 넣어주었다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class ApachePOIExcelWrite &#123; private static final String FILE_NAME = \"/Users/sskim/Downloads/POI_Excel_Example.xlsx\"; public static void main(String[] args) &#123; XSSFWorkbook workbook = new XSSFWorkbook(); XSSFSheet sheet = workbook.createSheet(\"Datatypes in Java\"); //sheet생성 Object[][] datatypes = &#123; //엑셀 셀 데이터 &#123;\"Datatype\", \"Type\", \"Size(in bytes)\"&#125;, &#123;\"int\", \"Primitive\", 2&#125;, &#123;\"float\", \"Primitive\", 4&#125;, &#123;\"double\", \"Primitive\", 8&#125;, &#123;\"char\", \"Primitive\", 1&#125;, &#123;\"String\", \"Non-Primitive\", \"No fixed size\"&#125; &#125;; int rowNum = 0; //열 System.out.println(\"Creating excel\"); for (Object[] datatype : datatypes) &#123; Row row = sheet.createRow(rowNum++); //열 생성 int colNum = 0; //행 for (Object field : datatype) &#123; Cell cell = row.createCell(colNum++); //Cell은 데이터 넣는 엑셀의 셀 부분을 생각하면된다. if (field instanceof String) &#123; cell.setCellValue((String) field); &#125; else if (field instanceof Integer) &#123; cell.setCellValue((Integer) field); &#125; &#125; &#125; try &#123; FileOutputStream outputStream = new FileOutputStream(FILE_NAME); workbook.write(outputStream); workbook.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Done\"); &#125;&#125; 엑셀 Read엑셀 Write와 비슷하게 웹에서 생각해보면 엑셀 업로드 기능같은게 있을 때 활용할 수 있을 것 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142public class ApachePOIExcelRead &#123; private static final String FILE_NAME = \"/Users/sskim/Downloads/POI_Excel_Example.xlsx\"; public static void main(String[] args) &#123; try &#123; //엑셀파일 위치 읽어들임 FileInputStream excelFile = new FileInputStream(new File(FILE_NAME)); //엑셀파일을 위치 넣어줌 Workbook workbook = new XSSFWorkbook(excelFile); //0번째 sheet를 불러옴 Sheet datatypeSheet = workbook.getSheetAt(0); //열 반복자 생성 Iterator&lt;Row&gt; rowIterator = datatypeSheet.iterator(); while (rowIterator.hasNext()) &#123; //열이 hasNext() 끝날때까지 반복하면서 현재 열을 얻음. Row currentRow = rowIterator.next(); //현재 열의 Cell 즉 엑셀 시트의 데이터 입력 부분 셀을 얻음. Iterator&lt;Cell&gt; cellIterator = currentRow.iterator(); while (cellIterator.hasNext()) &#123; //해당 셀을 반복 Cell currentCell = cellIterator.next(); if (currentCell.getCellTypeEnum() == CellType.STRING) &#123; System.out.print(currentCell.getStringCellValue()+\"\\t\\t\\t\\t\"); &#125; else if (currentCell.getCellTypeEnum() == CellType.NUMERIC) &#123; System.out.print(currentCell.getNumericCellValue()+\"\\t\\t\\t\\t\"); &#125; &#125; System.out.println(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 출처 Mkyong POI Library를 이용한 Excel Write","categories":[{"name":"정리","slug":"정리","permalink":"https://sskim91.github.io/categories/정리/"},{"name":"Java Library","slug":"정리/Java-Library","permalink":"https://sskim91.github.io/categories/정리/Java-Library/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"ApachePOI","slug":"ApachePOI","permalink":"https://sskim91.github.io/tags/ApachePOI/"}]},{"title":"Java String 공백 제거하기","slug":"Java-20180224-Java-String-공백-제거하기","date":"2018-02-23T17:29:59.000Z","updated":"2018-05-09T07:35:23.464Z","comments":true,"path":"2018/02/24/Java-20180224-Java-String-공백-제거하기/","link":"","permalink":"https://sskim91.github.io/2018/02/24/Java-20180224-Java-String-공백-제거하기/","excerpt":"문자열 앞 뒤 공백 없애기 - trim() 메서드 이용","text":"문자열 앞 뒤 공백 없애기 - trim() 메서드 이용 문자열 앞 뒤에 있는 공백은 trim() 메서드를 통해서 쉽게 없앨 수 있다. 123456String trimStr = \" ss kim \";trimStr = trimStr.trim();System.out.println(trimStr);//결과\"ss kim\" 결과를 보면 trim() 메서드는 문자열의 앞 뒤 공백만 지워줌 중간에 공백은 지워지지 않음 문자열 중간 사이 공백 없애기 - replaceall() 메서드 이용123456String replaceStr = \" ss kim \";replaceStr = replaceStr.replaceAll(\" \", \"\");System.out.println(replaceStr);//결과\"sskim\" 위와같이 해도 안될 때 참조 사이트[Problem trimming Japanese string in java]","categories":[{"name":"Programming","slug":"Programming","permalink":"https://sskim91.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://sskim91.github.io/categories/Programming/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"String","slug":"String","permalink":"https://sskim91.github.io/tags/String/"}]},{"title":"Level2 콜라츠 추측","slug":"알고리즘-자바-20180222-Level2-콜라츠-추측","date":"2018-02-21T17:14:34.000Z","updated":"2018-05-09T07:18:30.967Z","comments":true,"path":"2018/02/22/알고리즘-자바-20180222-Level2-콜라츠-추측/","link":"","permalink":"https://sskim91.github.io/2018/02/22/알고리즘-자바-20180222-Level2-콜라츠-추측/","excerpt":"문제 1937년 Collatz란 사람에 의해 제기된 이 추측은, 입력된 수가 짝수라면 2로 나누고, 홀수라면 3을 곱하고 1을 더한 다음, 결과로 나온 수에 같은 작업을 1이 될 때까지 반복할 경우 모든 수가 1이 된다는 추측입니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. collatz 함수를 만들어 입력된 수가 몇 번 만에 1이 되는지 반환해 주세요. 단, 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.","text":"문제 1937년 Collatz란 사람에 의해 제기된 이 추측은, 입력된 수가 짝수라면 2로 나누고, 홀수라면 3을 곱하고 1을 더한 다음, 결과로 나온 수에 같은 작업을 1이 될 때까지 반복할 경우 모든 수가 1이 된다는 추측입니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. collatz 함수를 만들어 입력된 수가 몇 번 만에 1이 되는지 반환해 주세요. 단, 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요. 문제를 풀고나서 다른 사람의 풀이를 봤을 때 나혼자 왜이렇게 어렵게 생각하고 푼거 같지 라는 생각이 들었다. 나는 List를 생성해서 거기에 계속 추가하면서 조건에 맞는 값이 나올때 까지 해야지 라는 생각으로 했는데 그냥 이런거 없이 해도 됬나보다.. 아 그리고 collatz() 의 파라미터로 int가 선언이 되어있는데 int의 최대값인 21473846을 넘어서면 오류가 나서 long 타입으로 바꾸어주었다. 1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;import java.util.List;class Collatz &#123; public int collatz(long num) &#123; int count = 0; int index = 0; List&lt;Long&gt; list = new ArrayList&lt;&gt;(); list.add(num); while (count != 500) &#123; if(list.get(index) == 1) break; if (list.get(index) % 2 == 0) &#123; list.add(list.get(index) / 2); index++; count++; &#125; else if (list.get(index) % 2 != 0) &#123; list.add((list.get(index) * 3) + 1); index++; count++; &#125; &#125; return count == 500 ? -1 : count; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; Collatz c = new Collatz(); int ex = 2147349583; System.out.println(c.collatz(ex)); &#125;&#125; 다른 사람의 풀이12345678910111213141516class Collatz &#123; public int collatz(int num) &#123; long n = (long)num; for(int i =0; i&lt;500; i++)&#123; if(n==1) return i; n = (n%2==0) ? n/2 : n*3+1; &#125; return -1; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; Collatz c = new Collatz(); int ex = 6; System.out.println(c.collatz(ex)); &#125;&#125; 다른 사람의 풀이12345678910111213141516171819202122232425262728293031class Collatz &#123; public int collatz(int num) &#123; int answer = 0; int count = 0; while (count &lt;= 500) &#123; if (num % 2 == 0) &#123; num = num / 2; count++; &#125; else if (num % 2 == 1) &#123; num = num * 3 + 1; count++; &#125; answer = count; if (num == 1) &#123; break; &#125; else if (count == 500) &#123; answer = -1; &#125; &#125; return answer; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; Collatz c = new Collatz(); int ex = 6; System.out.println(c.collatz(ex)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level2 정수 내림차순으로 배치하기","slug":"알고리즘-자바-20180221-Level2-정수-내림차순으로-배치하기","date":"2018-02-21T14:13:57.000Z","updated":"2018-05-09T07:18:30.967Z","comments":true,"path":"2018/02/21/알고리즘-자바-20180221-Level2-정수-내림차순으로-배치하기/","link":"","permalink":"https://sskim91.github.io/2018/02/21/알고리즘-자바-20180221-Level2-정수-내림차순으로-배치하기/","excerpt":"문제 reverseInt 메소드는 int형 n을 매개변수로 입력받습니다.n에 나타나는 숫자를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요.예를들어 n이 118372면 873211을 리턴하면 됩니다.n은 양의 정수입니다.","text":"문제 reverseInt 메소드는 int형 n을 매개변수로 입력받습니다.n에 나타나는 숫자를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요.예를들어 n이 118372면 873211을 리턴하면 됩니다.n은 양의 정수입니다. 정수를 받아서 정수 자체로는 정렬이 되지 않기때문에 문자형으로 바꾼후에 배열에 담았다. 그리고 이전에 배웠던 Arrays.sort() 에서 바로 역정렬을사용해서 정렬한후에 이걸 다시 문자열로 바꿔야되는데 방법을 찾지 못해서 그냥 쉽게 String 변수 하나 선언해서 거기에 현재 배열에 있는 값을 반복문을 통해서 하나씩 다 담았다..흠..뭔가 있을거 같은데 아직 너무 미숙한 것 같다. 그래도 정답이란다.. 123456789101112131415161718192021222324import java.util.Arrays;import java.util.Collections;public class ReverseInt &#123; public int reverseInt(int n)&#123; String[] convertStr = String.valueOf(n).split(\"\"); Arrays.sort(convertStr, Collections.reverseOrder()); String str = \"\"; for(int i=0; i&lt;convertStr.length; i++) &#123; str += convertStr[i]; &#125; return Integer.parseInt(str); &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)&#123; ReverseInt ri = new ReverseInt(); System.out.println(ri.reverseInt(118372)); &#125;&#125; 다른 사람의 풀이Java8 lambda(?) 를 이용해서 한번에 풀었다. 문제 풀면서 이렇게 한 사람이 있겠지 싶었는데 역시나 제일 위에 이 분의 코드가 보였다. 깔끔하고 좋은 것 같다. 1234567891011121314151617public class ReverseInt &#123; String res = \"\"; public int reverseInt(int n)&#123; res = \"\"; Integer.toString(n) .chars() .sorted() .forEach(c -&gt; res = Character.valueOf((char)c) + res); return Integer.parseInt(res); &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)&#123; ReverseInt ri = new ReverseInt(); System.out.println(ri.reverseInt(118372)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level2 소수 찾기","slug":"알고리즘-자바-20180221-Level2-소수-찾기","date":"2018-02-21T11:12:56.000Z","updated":"2018-05-09T07:18:30.967Z","comments":true,"path":"2018/02/21/알고리즘-자바-20180221-Level2-소수-찾기/","link":"","permalink":"https://sskim91.github.io/2018/02/21/알고리즘-자바-20180221-Level2-소수-찾기/","excerpt":"문제 numberOfPrime 메소드는 정수 n을 매개변수로 입력받습니다. 1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하도록 numberOfPrime 메소드를 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.(1은 소수가 아닙니다.) 10을 입력받았다면, 1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환5를 입력받았다면, 1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환","text":"문제 numberOfPrime 메소드는 정수 n을 매개변수로 입력받습니다. 1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하도록 numberOfPrime 메소드를 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.(1은 소수가 아닙니다.) 10을 입력받았다면, 1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환5를 입력받았다면, 1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환 123456789101112131415161718192021222324252627class NumOfPrime &#123; int numberOfPrime(int n) &#123; int result = 0; //소수 개수 boolean isPrime; // 함수를 완성하세요. for (int i=2; i&lt;=n; i++) &#123; isPrime = true; for (int j=2; j&lt;i; j++) &#123; if (i % j == 0) &#123; // 소수가 아님 isPrime = false; break; &#125; &#125; if (isPrime) &#123; result++; &#125; &#125; return result; &#125; public static void main(String[] args) &#123; NumOfPrime prime = new NumOfPrime(); System.out.println( prime.numberOfPrime(10) ); &#125;&#125; 다른 사람의 풀이다들 비슷하다. 12345678910111213141516171819202122class NumOfPrime &#123; int numberOfPrime(int n) &#123; int result = 0; for(int i=2; i&lt;=n; i++)&#123; for(int j=2; j&lt;=i; j++)&#123; if(j == i)&#123; ++result; &#125; else if(i%j == 0)&#123; break; &#125; &#125; &#125; return result; &#125; public static void main(String[] args) &#123; NumOfPrime prime = new NumOfPrime(); System.out.println( prime.numberOfPrime(10) ); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level2 하샤드수","slug":"알고리즘-자바-20180221-Level2-하샤드수","date":"2018-02-21T10:06:11.000Z","updated":"2018-05-09T07:18:30.967Z","comments":true,"path":"2018/02/21/알고리즘-자바-20180221-Level2-하샤드수/","link":"","permalink":"https://sskim91.github.io/2018/02/21/알고리즘-자바-20180221-Level2-하샤드수/","excerpt":"문제 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. Harshad함수는 양의 정수 n을 매개변수로 입력받습니다. 이 n이 하샤드수인지 아닌지 판단하는 함수를 완성하세요.예를들어 n이 10, 12, 18이면 True를 리턴 11, 13이면 False를 리턴하면 됩니다.","text":"문제 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. Harshad함수는 양의 정수 n을 매개변수로 입력받습니다. 이 n이 하샤드수인지 아닌지 판단하는 함수를 완성하세요.예를들어 n이 10, 12, 18이면 True를 리턴 11, 13이면 False를 리턴하면 됩니다. 정수를 받아서 자릿수를 더해야 되기 때문에 일단 문자열로 변환한 후에 split() 메소드를 사용해서 하나씩 나눈다음에 더했다. 그 이후에는 그 자릿수를 더한 수를 가지고 본래 넘어온 수를 나눠서 나누어 떨어지면 true 아니면 false를 반환하게 함! 그런데 변수명이나 이런거 어떻게 하면 잘 지을 수 있을까.. 내 코드에 항상 불만이다. 123456789101112131415161718192021public class HarshadNumber&#123; public boolean isHarshad(int num)&#123; String convertStr = String.valueOf(num); String[] strArr = convertStr.split(\"\"); int cipher = 0; for (int i=0; i&lt;strArr.length; i++) &#123; cipher += Integer.parseInt(strArr[i]); &#125; return num % cipher == 0 ? true : false; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)&#123; HarshadNumber sn = new HarshadNumber(); System.out.println(sn.isHarshad(18)); &#125;&#125; 다른 사람의 풀이나랑 거의 똑같은 풀이 -&gt; valueOf() 메소드가 String을 반환하기 때문에 바로 split() 메소드를 사용할 수 있다. 그리고 배열이나 리스트를 반복할 때는 자바의 향상된 for문을 사용하는게 좋다고 했다. 음 전체를 다 돌리는 거면 향상된 for문이 좋고, 제한된 숫자 만큼 반복을 돌리려면 기존에 for문을 돌리는게 낫다고 내가 속해있는 스터디의 스터디장님이 말씀한게 생각난다. 1234567891011121314151617181920212223public class HarshadNumber&#123; public boolean isHarshad(int num)&#123; String[] temp = String.valueOf(num).split(\"\"); int sum = 0; for (String s : temp) &#123; sum += Integer.parseInt(s); &#125; if (num % sum == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)&#123; HarshadNumber sn = new HarshadNumber(); System.out.println(sn.isHarshad(18)); &#125;&#125; 다른 사람의 풀이Java8을 활용한 풀이 12345678910111213141516import java.util.function.IntConsumer;public class HarshadNumber&#123; private int sum = 0; public boolean isHarshad(int num)&#123; sum = 0; Integer.toString(num).chars().forEach(c -&gt; sum += c - '0'); return num % sum == 0; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)&#123; HarshadNumber sn = new HarshadNumber(); System.out.println(sn.isHarshad(18)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 삼각형 출력하기","slug":"알고리즘-자바-20180221-Level1-삼각형-출력하기","date":"2018-02-21T09:29:30.000Z","updated":"2018-05-09T07:18:30.966Z","comments":true,"path":"2018/02/21/알고리즘-자바-20180221-Level1-삼각형-출력하기/","link":"","permalink":"https://sskim91.github.io/2018/02/21/알고리즘-자바-20180221-Level1-삼각형-출력하기/","excerpt":"문제 printTriangle 메소드는 양의 정수 num을 매개변수로 입력받습니다.다음을 참고해 *(별)로 높이가 num인 삼각형을 문자열로 리턴하는 printTriangle 메소드를 완성하세요printTriangle이 return하는 String은 개행문자(‘\\n’)로 끝나야 합니다. 높이가 3일때 1234&gt; *&gt; **&gt; ***&gt;","text":"문제 printTriangle 메소드는 양의 정수 num을 매개변수로 입력받습니다.다음을 참고해 *(별)로 높이가 num인 삼각형을 문자열로 리턴하는 printTriangle 메소드를 완성하세요printTriangle이 return하는 String은 개행문자(‘\\n’)로 끝나야 합니다. 높이가 3일때 1234&gt; *&gt; **&gt; ***&gt; 많이 찍어봤던 별 문제 처럼 그냥 for문 2개돌려서 정답을 제출했다. 123456789101112131415161718192021public class PrintTriangle &#123; public String printTriangle(int num)&#123; String stars = \"\"; for (int i=1; i&lt;=num; i++) &#123; for (int j=1; j&lt;=i; j++) &#123; stars += \"*\"; &#125; stars += \"\\n\"; &#125; return stars; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; PrintTriangle pt = new PrintTriangle(); System.out.println( pt.printTriangle(3) ); &#125;&#125; 다른 사람의 풀이사람들의 댓글이 많이 달려있는 코드이다. 보통 사람들 다 for문 2개로 해결했을텐데 for문 1개로 해결하였다. 1234567891011121314151617public class PrintTriangle &#123; public String printTriangle(int num)&#123; String result = \"\"; String stars = \"*\"; for(int i=0; i&lt;num; ++i)&#123; result += stars+\"\\n\"; stars += \"*\"; &#125; return result; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; PrintTriangle pt = new PrintTriangle(); System.out.println( pt.printTriangle(3) ); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 수박수박수박수?","slug":"알고리즘-자바-20180220-Level1-수박수박수박수","date":"2018-02-20T13:22:31.000Z","updated":"2018-05-09T07:18:30.967Z","comments":true,"path":"2018/02/20/알고리즘-자바-20180220-Level1-수박수박수박수/","link":"","permalink":"https://sskim91.github.io/2018/02/20/알고리즘-자바-20180220-Level1-수박수박수박수/","excerpt":"문제 water_melon함수는 정수 n을 매개변수로 입력받습니다.길이가 n이고, 수박수박수…와 같은 패턴을 유지하는 문자열을 리턴하도록 함수를 완성하세요. 예를들어 n이 4이면 ‘수박수박’을 리턴하고 3이라면 ‘수박수’를 리턴하면 됩니다.","text":"문제 water_melon함수는 정수 n을 매개변수로 입력받습니다.길이가 n이고, 수박수박수…와 같은 패턴을 유지하는 문자열을 리턴하도록 함수를 완성하세요. 예를들어 n이 4이면 ‘수박수박’을 리턴하고 3이라면 ‘수박수’를 리턴하면 됩니다. 일단 ‘수’와 ‘박’을 하나하나 담아둘 공간이 필요할 것 같아서 char[] 배열을 생성했다. 그리구나서 반복문을 돌려주면서 문자를 하나씩 넣어 주었다. 12345678910111213141516171819202122public class WaterMelon &#123; public String watermelon(int n)&#123; char[] subakStr = new char[n]; for (int i=0; i&lt;subakStr.length; i++) &#123; subakStr[i] = '수'; if (i % 2 != 0) &#123; subakStr[i] = '박'; &#125; &#125; return String.valueOf(subakStr); &#125; // 실행을 위한 테스트코드입니다. public static void main(String[] args)&#123; WaterMelon wm = new WaterMelon(); System.out.println(\"n이 3인 경우: \" + wm.watermelon(3)); System.out.println(\"n이 4인 경우: \" + wm.watermelon(4)); &#125;&#125; 다른 사람의 풀이\\0 이 뭔지 몰라서 검색하다가 이런 글을 찾았다. 자바에서 문자열을 반복하는 방법 12345678910111213public class WaterMelon &#123; public String watermelon(int n)&#123; return new String(new char [n/2+1]).replace(\"\\0\", \"수박\").substring(0,n); &#125; // 실행을 위한 테스트코드입니다. public static void main(String[] args)&#123; WaterMelon wm = new WaterMelon(); System.out.println(\"n이 3인 경우: \" + wm.watermelon(3)); System.out.println(\"n이 4인 경우: \" + wm.watermelon(4)); &#125;&#125; 다른 사람의 풀이배열과 StringBuffer를 활용한 문제 풀이 1234567891011121314151617181920212223public class WaterMelon &#123; public String watermelon(int n)&#123; String array[]=&#123;\"수\",\"박\"&#125;; StringBuffer sb= new StringBuffer(); for(int i=1;i&lt;=n;i++)&#123; if(i%2==1)&#123; sb.append(array[0]); &#125;else if(i%2==0)&#123; sb.append(array[1]); &#125; &#125; String result=sb.toString(); return result; &#125; // 실행을 위한 테스트코드입니다. public static void main(String[] args)&#123; WaterMelon wm = new WaterMelon(); System.out.println(\"n이 3인 경우: \" + wm.watermelon(3)); System.out.println(\"n이 4인 경우: \" + wm.watermelon(4)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 나누어 떨어지는 숫자 배열","slug":"알고리즘-자바-20180219-Level1-나누어-떨어지는-숫자-배열","date":"2018-02-18T16:03:19.000Z","updated":"2018-05-09T07:18:30.967Z","comments":true,"path":"2018/02/19/알고리즘-자바-20180219-Level1-나누어-떨어지는-숫자-배열/","link":"","permalink":"https://sskim91.github.io/2018/02/19/알고리즘-자바-20180219-Level1-나누어-떨어지는-숫자-배열/","excerpt":"문제 divisible 메소드는 int형 배열 array와 int divisor를 매개변수로 받습니다.array의 각 element 중 divisor로 나누어 떨어지는 값만 포함하는 새로운 배열을 만들어서 반환하도록 divisible에 코드를 작성해 보세요. 예를들어 array가 {5, 9, 7, 10}이고 divisor가 5이면 {5, 10}을 리턴해야 합니다.","text":"문제 divisible 메소드는 int형 배열 array와 int divisor를 매개변수로 받습니다.array의 각 element 중 divisor로 나누어 떨어지는 값만 포함하는 새로운 배열을 만들어서 반환하도록 divisible에 코드를 작성해 보세요. 예를들어 array가 {5, 9, 7, 10}이고 divisor가 5이면 {5, 10}을 리턴해야 합니다. 풀면서 아 뭔가 더 쉽게 할 수 있는 분명히 좋은 코드가 있겠지 생각하고 일단 답 맞추고 다른 사람의 풀이를 봐보자 했는데 역시나 한 줄로 끝내버리는 코드가 있었다. 나는 지금 for문을 3번이나 돌리면서 풀어버렸다.. 조금더 열정적으로 생각하면서 풀어봐야겠다!!! 12345678910111213141516171819202122232425262728293031323334class Divisible &#123; public int[] divisible(int[] array, int divisor) &#123; //ret에 array에 포함된 정수중, divisor로 나누어 떨어지는 숫자를 순서대로 넣으세요. //처음 매개변수 배열을 담을 list 생성 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i=0; i&lt;array.length; i++) &#123; list.add(array[i]); &#125; List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); //리스트를 divisor로 나누어 떨어지는 숫자를 넣음 for (int i=0; i&lt;list.size(); i++) &#123; if (list.get(i) % divisor == 0) &#123; list2.add(list.get(i)); &#125; &#125; int[] ret = new int[list2.size()]; for (int i=0; i&lt;list2.size(); i++) &#123; ret[i] = list2.get(i); &#125; return ret; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; Divisible div = new Divisible(); int[] array = &#123;5, 9, 7, 10&#125;; System.out.println( Arrays.toString( div.divisible(array, 5) )); &#125;&#125; 다른 사람의 풀이123456789101112class Divisible &#123; public int[] divisible(int[] array, int divisor) &#123; //ret에 array에 포함된 정수중, divisor로 나누어 떨어지는 숫자를 순서대로 넣으세요. return Arrays.stream(array).filter(factor -&gt; factor % divisor == 0).toArray(); &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; Divisible div = new Divisible(); int[] array = &#123;5, 9, 7, 10&#125;; System.out.println( Arrays.toString( div.divisible(array, 5) )); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 서울에서 김서방 찾기","slug":"알고리즘-자바-20180218-Level1-서울에서-김서방-찾기","date":"2018-02-18T13:09:01.000Z","updated":"2018-05-09T07:18:30.966Z","comments":true,"path":"2018/02/18/알고리즘-자바-20180218-Level1-서울에서-김서방-찾기/","link":"","permalink":"https://sskim91.github.io/2018/02/18/알고리즘-자바-20180218-Level1-서울에서-김서방-찾기/","excerpt":"문제 findKim 함수(메소드)는 String형 배열 seoul을 매개변수로 받습니다. seoul의 element중 Kim의 위치 x를 찾아, 김서방은 x에 있다는 String을 반환하세요.seoul에 Kim은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다.","text":"문제 findKim 함수(메소드)는 String형 배열 seoul을 매개변수로 받습니다. seoul의 element중 Kim의 위치 x를 찾아, 김서방은 x에 있다는 String을 반환하세요.seoul에 Kim은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다. List의 indexOf() 메서드를 사용했다. indexOf() 메소드는 특정 요소의 인덱스 값을 찾을 수 있다. 12345678910111213141516public class FindKim &#123; public String findKim(String[] seoul)&#123; //x에 김서방의 위치를 저장하세요. int x = 0; List&lt;String&gt; stringList = Arrays.asList(seoul); x = stringList.indexOf(\"Kim\"); return \"김서방은 \"+ x + \"에 있다\"; &#125; // 실행을 위한 테스트코드입니다. public static void main(String[] args) &#123; FindKim kim = new FindKim(); String[] names = &#123;\"Queen\", \"Tod\",\"Kim\"&#125;; System.out.println(kim.findKim(names)); &#125;&#125; 다른 사람의 풀이123456789101112131415public class FindKim &#123; public String findKim(String[] seoul)&#123; //x에 김서방의 위치를 저장하세요. int x = Arrays.asList(seoul).indexOf(\"Kim\"); return \"김서방은 \"+ x + \"에 있다\"; &#125; // 실행을 위한 테스트코드입니다. public static void main(String[] args) &#123; FindKim kim = new FindKim(); String[] names = &#123;\"Queen\", \"Tod\",\"Kim\"&#125;; System.out.println(kim.findKim(names)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 문자열 내림차순으로 배치하기","slug":"알고리즘-자바-20180218-Level1-문자열-내림차순으로-배치하기","date":"2018-02-17T16:02:13.000Z","updated":"2018-05-09T07:18:30.966Z","comments":true,"path":"2018/02/18/알고리즘-자바-20180218-Level1-문자열-내림차순으로-배치하기/","link":"","permalink":"https://sskim91.github.io/2018/02/18/알고리즘-자바-20180218-Level1-문자열-내림차순으로-배치하기/","excerpt":"문제 reverseStr 메소드는 String형 변수 str을 매개변수로 입력받습니다.str에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 String을 리턴해주세요.str는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.예를들어 str이 Zbcdefg면 gfedcbZ을 리턴하면 됩니다.","text":"문제 reverseStr 메소드는 String형 변수 str을 매개변수로 입력받습니다.str에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 String을 리턴해주세요.str는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.예를들어 str이 Zbcdefg면 gfedcbZ을 리턴하면 됩니다. 사실 나는 문제를 이런식으로 풀었는데 제출해보면 정답이 아니라 그래서 인터넷에 기존에 풀어봤던 사람들 것을 참고해보니까 방식이 조금 다른 것 같았다. 이런 문제들을 조금씩 풀어보면서 각 클래스의 API 메소드들을 조금씩 알게되고 써봄으로써 이해하는 것 같다..(기본적인것이라도..) 12345678910111213141516171819202122public class ReverseStr &#123; public String reverseStr(String str)&#123; String[] strArr = str.split(\"\"); List&lt;String&gt; stringList = Arrays.asList(strArr); Collections.reverse(stringList); String result = \"\"; for (String reverseStr : stringList) &#123; result += reverseStr; &#125; return result; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; ReverseStr rs = new ReverseStr(); System.out.println( rs.reverseStr(\"Zbcdefg\") ); &#125;&#125; 다른 사람의 풀이 (1)이 코드는 매개변수 str로 받은 것을 toCharArray() 를 사용해서 배열로 받아온 후에 바로 StringBuilder 객체를 사용해서 리턴한다. StringBuilder의 객체의 메소드는 String을 바로 반환하기때문에 저렇게 메소드 체인으로 쓸 수가 있다. StringBuilder에 reverse() 메소드가 있는 것은 처음 알앗다. 12345678910111213public class ReverseStr &#123; public String reverseStr(String str)&#123; char[] sol = str.toCharArray(); Arrays.sort(sol); return new StringBuilder(new String(sol)).reverse().toString(); &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; ReverseStr rs = new ReverseStr(); System.out.println( rs.reverseStr(\"Zbcdefg\") ); &#125;&#125; 다른 사람의 풀이 (2)Collections.reverseOrder()는 역순을 반환하는 Comparator 객체를 반환한다. 123456789101112131415161718public class ReverseStr &#123; public String reverseStr(String str)&#123; String[] arry = str.split(\"\"); Arrays.sort(arry, Collections.reverseOrder()); StringBuffer sb = new StringBuffer(); for( String s : arry ) &#123; sb.append(s); &#125; return sb.toString(); &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; ReverseStr rs = new ReverseStr(); System.out.println( rs.reverseStr(\"Zbcdefg\") ); &#125;&#125; 배운점 배열을 정렬할때는 Arrays.sort() 메소드를 사용한다. List를 정렬할때는 Collections.sort() 메소드를 사용한다. 자바 정렬 Comparable Comparator 확실히 알고 넘어가기","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 가운데 글자 가져오기","slug":"알고리즘-자바-20180217-Level1-가운데-글자-가져오기","date":"2018-02-17T11:05:10.000Z","updated":"2018-05-09T07:18:30.965Z","comments":true,"path":"2018/02/17/알고리즘-자바-20180217-Level1-가운데-글자-가져오기/","link":"","permalink":"https://sskim91.github.io/2018/02/17/알고리즘-자바-20180217-Level1-가운데-글자-가져오기/","excerpt":"문제 getMiddle메소드는 하나의 단어를 입력 받습니다. 단어를 입력 받아서 가운데 글자를 반환하도록 getMiddle메소드를 만들어 보세요. 단어의 길이가 짝수일경우 가운데 두글자를 반환하면 됩니다.예를들어 입력받은 단어가 power이라면 w를 반환하면 되고, 입력받은 단어가 test라면 es를 반환하면 됩니다.","text":"문제 getMiddle메소드는 하나의 단어를 입력 받습니다. 단어를 입력 받아서 가운데 글자를 반환하도록 getMiddle메소드를 만들어 보세요. 단어의 길이가 짝수일경우 가운데 두글자를 반환하면 됩니다.예를들어 입력받은 단어가 power이라면 w를 반환하면 되고, 입력받은 단어가 test라면 es를 반환하면 됩니다. 일단 문제를 풀었다. charAt() 메소드를 통해서 문자열의 특정 부분을 가져오는 부분을 활용해서 풀었는데 정답을 확인하고 다른 사람의 풀이를 보고 아놔~..를 외쳤다 ㅋㅋㅋ 왜 substring() 메소드를 생각하지 못했지.. 한줄로 끝낼 수 있었던 것이다..(한심) 열심히 공부하자.. 123456789101112131415161718192021class StringExercise&#123; String getMiddle(String word)&#123; int wordLength = word.length(); String result = \"\"; if (wordLength % 2 == 0) &#123; result = \"\" + word.charAt((wordLength / 2) - 1) +word.charAt(wordLength / 2); &#125; else &#123; result = \"\" + word.charAt(wordLength / 2); &#125; return result; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)&#123; StringExercise se = new StringExercise(); System.out.println(se.getMiddle(\"power\")); &#125;&#125; 다른 사람의 풀이1234567891011class StringExercise&#123; String getMiddle(String word)&#123; return word.substring((word.length()-1)/2, word.length()/2 + 1); &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)&#123; StringExercise se = new StringExercise(); System.out.println(se.getMiddle(\"power\")); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 스트링을 숫자로 바꾸기","slug":"알고리즘-자바-20180217-Level1-스트링을-숫자로-바꾸기","date":"2018-02-17T10:33:51.000Z","updated":"2018-05-09T07:18:30.965Z","comments":true,"path":"2018/02/17/알고리즘-자바-20180217-Level1-스트링을-숫자로-바꾸기/","link":"","permalink":"https://sskim91.github.io/2018/02/17/알고리즘-자바-20180217-Level1-스트링을-숫자로-바꾸기/","excerpt":"문제 strToInt 메소드는 String형 str을 매개변수로 받습니다.str을 숫자로 변환한 결과를 반환하도록 strToInt를 완성하세요.예를들어 str이 1234이면 1234를 반환하고, -1234이면 -1234를 반환하면 됩니다.str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다.","text":"문제 strToInt 메소드는 String형 str을 매개변수로 받습니다.str을 숫자로 변환한 결과를 반환하도록 strToInt를 완성하세요.예를들어 str이 1234이면 1234를 반환하고, -1234이면 -1234를 반환하면 됩니다.str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다. 굉장히 쉬운 문제였다. 그냥 String 문자열을 Int형으로 바꿔주는 parseInt() 메소드만 알면 편하게 풀 수 있는 문제였다. 근데 알고리즘 문제가 이런식으로 푸는게 맞는 방법인지는 모르겠다. 1234567891011public class StrToInt &#123; public int getStrToInt(String str) &#123; return Integer.parseInt(str); &#125; //아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String args[]) &#123; StrToInt strToInt = new StrToInt(); System.out.println(strToInt.getStrToInt(\"-1234\")); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 최대값과 최소값","slug":"알고리즘-자바-20180217-Level1-최대값과-최소값","date":"2018-02-17T09:35:45.000Z","updated":"2018-05-09T07:18:30.966Z","comments":true,"path":"2018/02/17/알고리즘-자바-20180217-Level1-최대값과-최소값/","link":"","permalink":"https://sskim91.github.io/2018/02/17/알고리즘-자바-20180217-Level1-최대값과-최소값/","excerpt":"문제 getMinMaxString 메소드는 String형 변수 str을 매개변수로 입력받습니다.str에는 공백으로 구분된 숫자들이 저장되어 있습니다.str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 (최소값) (최대값)형태의 String을 반환하는 메소드를 완성하세요.예를들어 str이 1 2 3 4라면 1 4를 리턴하고, -1 -2 -3 -4라면 -4 -1을 리턴하면 됩니다.","text":"문제 getMinMaxString 메소드는 String형 변수 str을 매개변수로 입력받습니다.str에는 공백으로 구분된 숫자들이 저장되어 있습니다.str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 (최소값) (최대값)형태의 String을 반환하는 메소드를 완성하세요.예를들어 str이 1 2 3 4라면 1 4를 리턴하고, -1 -2 -3 -4라면 -4 -1을 리턴하면 됩니다. 일단 공백으로 구분되어 있다고 하길래 바로 문자열 메소드인 split을 생각해내긴 했다. 그런데 최대값, 최소값을 비교하는 부분에 있어서 코드가 깔끔하지 못한 것 같다. 아래의 다른사람의 풀이를 봐도 그냥 바로 Arrays의 클래스의 sort 메소드만 사용할줄 알아도 바로 정렬이 된다. 사실 다 어디선가 봤고 써봤는데 기억이 안나고 막상 실상황에 사용하려고하면 잘 생각이 나질 않는다. 앞으로 이런 문제를 통해서 계속 연습해 나가야 할 것 같다. 123456789101112131415161718192021222324252627282930313233public class GetMinMaxString &#123; public String getMinMaxString(String str) &#123; String[] strArr = str.split(\" \"); int[] intArr = new int[strArr.length]; for (int i=0; i&lt;strArr.length; i++) &#123; intArr[i] = Integer.parseInt(strArr[i]); &#125; int min = 0; int max = 0; for (int i=0; i&lt;intArr.length; i++) &#123; if (min &gt; intArr[i]) &#123; min = intArr[i]; &#125; if (max &lt; intArr[i]) &#123; max = intArr[i]; &#125; &#125; String result = min +\" \"+ max; return result; &#125; public static void main(String[] args) &#123; String str = \"100 2 3 15\"; GetMinMaxString minMax = new GetMinMaxString(); //아래는 테스트로 출력해 보기 위한 코드입니다. System.out.println(\"최대값과 최소값은?\" + minMax.getMinMaxString(str)); &#125;&#125; 다른 사람의 풀이 (1)12345678910111213141516171819202122232425public class GetMinMaxString &#123; public String getMinMaxString(String str) &#123; String strArr[] = str.split(\" \"); int arrInt[] = new int [strArr.length]; for(int i=0; i&lt;strArr.length; i++)&#123; arrInt[i] = Integer.parseInt(strArr[i]); &#125; Arrays.sort(arrInt); String result = arrInt[0] + \" \" + arrInt[strArr.length-1]; return result; &#125; public static void main(String[] args) &#123; String str = \"1 2 3 4\"; GetMinMaxString minMax = new GetMinMaxString(); //아래는 테스트로 출력해 보기 위한 코드입니다. System.out.println(\"최대값과 최소값은?\" + minMax.getMinMaxString(str)); &#125;&#125; 다른 사람의 풀이(2)딱 필요한 것만 있는듯한 코드. 12345678910111213141516171819202122public class GetMinMaxString &#123; public String getMinMaxString(String str) &#123; String[] tmp = str.split(\" \"); int min, max, n; min = max = Integer.parseInt(tmp[0]); for (int i = 1; i &lt; tmp.length; i++) &#123; n = Integer.parseInt(tmp[i]); if(min &gt; n) min = n; if(max &lt; n) max = n; &#125; return min + \" \" + max; &#125; public static void main(String[] args) &#123; String str = \"1 2 3 4\"; GetMinMaxString minMax = new GetMinMaxString(); //아래는 테스트로 출력해 보기 위한 코드입니다. System.out.println(\"최대값과 최소값은?\" + minMax.getMinMaxString(str)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 약수의 합","slug":"알고리즘-자바-20180217-Level1-약수의-합","date":"2018-02-17T09:33:27.000Z","updated":"2018-05-09T07:18:30.966Z","comments":true,"path":"2018/02/17/알고리즘-자바-20180217-Level1-약수의-합/","link":"","permalink":"https://sskim91.github.io/2018/02/17/알고리즘-자바-20180217-Level1-약수의-합/","excerpt":"문제 어떤 수를 입력받아 그 수의 약수를 모두 더한 수 sumDivisor 함수를 완성해 보세요. 예를 들어 12가 입력된다면 12의 약수는 [1, 2, 3, 4, 6, 12]가 되고, 총 합은 28이 되므로 28을 반환해 주면 됩니다.","text":"문제 어떤 수를 입력받아 그 수의 약수를 모두 더한 수 sumDivisor 함수를 완성해 보세요. 예를 들어 12가 입력된다면 12의 약수는 [1, 2, 3, 4, 6, 12]가 되고, 총 합은 28이 되므로 28을 반환해 주면 됩니다. 123456789101112131415161718class SumDivisor &#123; public int sumDivisor(int num) &#123; int answer = 0; for (int i=1; i&lt;=num; i++) &#123; if (num % i == 0) &#123; answer += i; &#125; &#125; return answer; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; SumDivisor c = new SumDivisor(); System.out.println(c.sumDivisor(12)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 짝수와홀수","slug":"알고리즘-자바-20180216-Level1-짝수와홀수","date":"2018-02-16T13:31:35.000Z","updated":"2018-05-09T07:18:30.965Z","comments":true,"path":"2018/02/16/알고리즘-자바-20180216-Level1-짝수와홀수/","link":"","permalink":"https://sskim91.github.io/2018/02/16/알고리즘-자바-20180216-Level1-짝수와홀수/","excerpt":"문제 evenOrOdd 메소드는 int형 num을 매개변수로 받습니다. num이 짝수일 경우 Even을 반환하고 홀수인 경우 Odd를 반환하도록 evenOrOdd에 코드를 작성해 보세요. num은 0이상의 정수이며, num이 음수인 경우는 없습니다.","text":"문제 evenOrOdd 메소드는 int형 num을 매개변수로 받습니다. num이 짝수일 경우 Even을 반환하고 홀수인 경우 Odd를 반환하도록 evenOrOdd에 코드를 작성해 보세요. num은 0이상의 정수이며, num이 음수인 경우는 없습니다. 문제를 제출하고 다른 사람의 풀이랑 똑같았다. 다만 삼항연산자 부분을 그냥 return 문에다 코딩을 했다는 점이 다르다. 가독성을 위해서 한줄로 끝내는게 더 나은것? 같다.. 코딩 규약을 좀 찾아봐야할 것 같다. 1234567891011121314151617public class EvenOrOdd &#123; String evenOrOdd(int num) &#123; String result = \"\"; result = (num % 2 == 0) ? \"Even\" : \"Odd\"; return result; //다른 사람의 풀이 //return num%2==0 ? \"Even\" : \"Odd\"; &#125; public static void main(String[] args) &#123; String str = \"1 2 3 4\"; EvenOrOdd evenOrOdd = new EvenOrOdd(); //아래는 테스트로 출력해 보기 위한 코드입니다. System.out.println(\"결과 : \" + evenOrOdd.evenOrOdd(3)); System.out.println(\"결과 : \" + evenOrOdd.evenOrOdd(2)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 평균구하기","slug":"알고리즘-자바-20180216-Level1-평균구하기","date":"2018-02-16T13:05:23.000Z","updated":"2018-05-09T07:18:30.965Z","comments":true,"path":"2018/02/16/알고리즘-자바-20180216-Level1-평균구하기/","link":"","permalink":"https://sskim91.github.io/2018/02/16/알고리즘-자바-20180216-Level1-평균구하기/","excerpt":"문제 함수를 완성해서 매개변수 array의 평균값을 return하도록 만들어 보세요. 어떠한 크기의 array가 와도 평균값을 구할 수 있어야 합니다.","text":"문제 함수를 완성해서 매개변수 array의 평균값을 return하도록 만들어 보세요. 어떠한 크기의 array가 와도 평균값을 구할 수 있어야 합니다. 굉장히 쉬운 문제에 속한다. 대부분 다 이렇게 풀었을 것 같아서 조금 공부해봤던 Java8의 stream을 사용해서 할려고 했는데 공부를 대충해서 그런지 잘 안되서 그냥 이렇게 풀고 다른 사람 풀이를 보니까 다른사람이 stream을 활용해서 1줄로 끝냈다. Java8 제대로 다시 공부해야겠다. 나의 풀이123456789101112131415161718192021public class GetMean &#123; public int getMean(int[] array) &#123; int count = array.length; int sum = 0; for (int i = 0; i &lt; count; i++) &#123; sum += array[i]; &#125; int avg = sum / count; return avg; &#125; public static void main(String[] args) &#123; int x[] = &#123;5, 4, 3&#125;; GetMean getMean = new GetMean(); // 아래는 테스트로 출력해 보기 위한 코드입니다. System.out.println(\"평균값 : \" + getMean.getMean(x)); &#125;&#125; 다른 사람의 풀이1234567891011121314import java.util.Arrays;public class GetMean &#123; public int getMean(int[] array) &#123; return (int) Arrays.stream(array).average().orElse(0); &#125; public static void main(String[] args) &#123; int x[] = &#123;5, 4, 3&#125;; GetMean getMean = new GetMean(); // 아래는 테스트로 출력해 보기 위한 코드입니다. System.out.println(\"평균값 : \" + getMean.getMean(x)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Level1 최대공약수와 최소공배수","slug":"알고리즘-자바-20180216-Level1-최대공약수와-최소공배수","date":"2018-02-16T11:52:21.000Z","updated":"2018-05-09T07:18:30.965Z","comments":true,"path":"2018/02/16/알고리즘-자바-20180216-Level1-최대공약수와-최소공배수/","link":"","permalink":"https://sskim91.github.io/2018/02/16/알고리즘-자바-20180216-Level1-최대공약수와-최소공배수/","excerpt":"문제 두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환해주는 gcdlcm 함수를 완성해 보세요. 배열의 맨 앞에 최대공약수, 그 다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 gcdlcm(3,12) 가 입력되면, [3, 12]를 반환해주면 됩니다.","text":"문제 두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환해주는 gcdlcm 함수를 완성해 보세요. 배열의 맨 앞에 최대공약수, 그 다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 gcdlcm(3,12) 가 입력되면, [3, 12]를 반환해주면 됩니다. 일단 문제를 풀기 전에 최대공약수 최소공배수에 대한 개념이 미약해서 찾아보고 여기에 대한 알고리즘을 정리한 사이트가 있어서 그 부분을 참조했다. 1. 최대공약수 (Greatest Common Factor, GCF) 두 개 이상의 수가 공통으로 가지고 있는 약수 중 가장 큰 수 8의 약수 : 1, 2, 4, 8 12의 약수 : 1, 2, 3, 4, 6, 12 8과 12의 최대공약수 : 4 2. 최소공배수 (the Least Common Multiple, LCM) 두 개 이상의 수가 공통으로 가지는 배수 중 가장 작은 수 3의 배수 : 3, 6, 9, 12, 15.. 5의 배수 5, 10, 15, 20.. 3과 5의 최소공배수 : 15 3. 서로소 (relative prime) 1 외의 공약수를 갖지 않는 두 수 ex) 7, 11 는 1 외의 공약수가 없으므로 서로소이다. 4. 최대공약수 구하는 알고리즘 1) 유클리드(Euclidean) 공식 이용 큰 수 A를 작은 수 B로 나누어 떨어지면, A, B의 최대공약수는 B A를 B로 나누었을 때 나머지가 R이면, A, B의 최대공약수는 R과 B의 최대공약수와 같다. ​ GCM(A,B) = GCM(B,R) / ex) GCM(15,12) = GCM(12,3) 유클리드 공식 이용 알고리즘 순서 a. 두 수 A, B 중 큰 수, 작은 수를 판별한다. b. 큰 수를 작은 수로 나누어 나머지를 구한다. ​ - if 나머지가 0 : 작은 수가 최대공약수 ​ - if 나머지가 0이 아니면 : 나누기 반복 5. 최소공배수 구하는 알고리즘 최소공배수(LCM) = A x B / 최대공약수(GCD) 이므로 위의 최대공약수 알고리즘으로 최대공약수를 구하고 A x B x GCD 를 구하면 됨 A = a x GCD / B = b x GCD (a, b는 서로소) LCM = a x b x GCD = A x B / GCD 출처 - 최대공약수 최소공배수 구하는 알고리즘 정리 1234567891011121314151617181920212223242526import java.util.Arrays;public class TryHelloWorld &#123; public int[] gcdlcm(int a, int b) &#123; int[] answer = new int[2]; int min = Math.min(a,b); int max = Math.max(a,b); int mod; while (min &gt; 0) &#123; mod = max % min; max = min; min = mod; &#125; answer[0] = max; answer[1] = (a*b)/answer[0]; //최소공배수는 두 수를 곱한 값에서 최대공약수로 나눠주면 최소공배수가 된다. return answer; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; TryHelloWorld c = new TryHelloWorld(); System.out.println(Arrays.toString(c.gcdlcm(3, 12))); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/categories/Algorithm/"},{"name":"Programmers","slug":"Algorithm/Programmers","permalink":"https://sskim91.github.io/categories/Algorithm/Programmers/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://sskim91.github.io/tags/Algorithm/"}]},{"title":"Servlet 이해하기","slug":"Web-Developer-20180113-Servlet-이해하기","date":"2018-01-12T16:48:29.000Z","updated":"2018-05-09T07:20:10.148Z","comments":true,"path":"2018/01/13/Web-Developer-20180113-Servlet-이해하기/","link":"","permalink":"https://sskim91.github.io/2018/01/13/Web-Developer-20180113-Servlet-이해하기/","excerpt":"웹개발자가 되기로 하고 나서 여러가지 기술을 배웠다. 그러나 정작 어디서 들어본 용어만 많고 정작 Servlet이 뭐냐고 물어보면 얼버무리게 되는게 현재 나의 상황인 것 같다. 지금이라도 조금씩 용어를 알고 정리를 해야겠다. 각설은 이만하고 Servlet 이란 무엇일까?","text":"웹개발자가 되기로 하고 나서 여러가지 기술을 배웠다. 그러나 정작 어디서 들어본 용어만 많고 정작 Servlet이 뭐냐고 물어보면 얼버무리게 되는게 현재 나의 상황인 것 같다. 지금이라도 조금씩 용어를 알고 정리를 해야겠다. 각설은 이만하고 Servlet 이란 무엇일까? 위키백과에서는 이렇게 정의하고 있다. 자바 서블릿(Java Servlet)은 자바)를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 “서블릿”이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다. 서블릿은 JSP와 비슷한 점이 있지만, JSP가 HTML 문서 안에 Java 코드를 포함하고 있는 반면, 서블릿은 자바 코드 안에 HTML을 포함하고 있다는 차이점이 있다. 자바 서블릿은 자바 EE 사양의 일부분으로, 주로 이 기능을 이용하여 쇼핑몰이나 온라인 뱅킹 등의 다양한 웹 시스템이 구현되고 있다. CGI는 요청이 있을 때마다 새로운 프로세스가 생성되어 응답하는 데 비해, 자바 서블릿은 외부 요청마다 프로세스보다 가벼운 스레드로써 응답하므로 보다 가볍다. 또한, 자바 서블릿은 자바로 구현되므로 다양한 플랫폼에서 동작한다. 위키백과 잠시 위키백과에서 나온 CGI(Common Gateway Interface) 란 무엇일까? 사용자가 웹 브라우저를 통해서 화면을 보고 싶으면 웹 브라우저를 통해서 웹 서버에게 HTTP 프로토콜로 요청을 하게된다. 이때 웹 서버는 그 요청을 처리하기 위해서 애플리케이션을 찾아서 실행을 하게 되고 애플리케이션은 웹서버로 들어온 요청에 대해서 작업을 수행한 후에 작업의 결과를 웹 서버에게 전달한다. 이후 웹 서버는 애플리케이션이 건네 준 결과를 받아서 웹 브라우저에 결과를 전달한다. 이 과정에서 웹서버와 웹 애플리케이션 사이에서 정보를 주고 받는 방법이나 규약이 CGI라고 할 수 있다. 서블릿은 자바로 구현된 CGI 프로그램이고 자바로 웹 어플리케이션을 개발할 수 있도록 하기 위해 만들어 졌다. 즉 자바 서블릿은 클라이언트의 HTTP 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 자바 프로그램이며 서블릿 컨테이너 내에서 실행된다. 라고 이해하면 될 것 같다. 서블릿 동작 과정 사용자가 URL을 클릭하면 HTTP Request를 Servlet Container에 보낸다. Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다. 사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다. (DD를 참조하여 분석) 컨테이너는 서블릿 service() 메소드를 호출하며, POST, GET여부에 따라 doGet() 또는 doPost()가 호출된다. doGet() or doPost() 메소드는 동적인 페이지를 생성한 후 HttpServletResponse객체에 응답을 보낸다. 응답이 완료되면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다. 그렇다면 여기서 나오는 서블릿 컨테이너란 무엇일까? Servlet Container 란?서블릿을 서버에서 실행하는 자바 프로그램이라고 했는데 이 서블릿을 관리해주는 역할을 하는 것이 서블릿 컨테이너다. 서블릿 컨테이너는 클라이언트에서 전송되는 서블릿 요청에 대하여 서블릿을 수행하는 프로그램이다. 서블릿 컨테이너의 역할 HTTP 요청을 받아서 서블릿을 실행시키고, 그 결과를 사용자 웹 브라우저에게 전달해주는 기능을 제공하는 컴포넌트 이다. 서블릿이 제공하는 기능을 실행시켜주며 관리해주고 서블릿의 생명주기 (LifeCycle)을 관리하고 요청에 따른 Thread를 생성해 준다. 서블릿과 웹 서버가 통신하기 용이하게 해준다. 즉 통신 할 수 있는 방법을 제공한다. 멀티 스레딩을 지원하여 클라이언트의 다중 요청을 알아서 처리해준다. Servlet의 수행 흐름 다음 그림은 서블릿을 브라우저에서 URL 문자열로 요청할 경우 그 수행 순서를 나타낸 그림이다. 브라우저에서 서블릿을 요청하는 HTTP URL 문자열을 사용하여 수행을 요청한다. WAS 안의 웹 서버가 서블릿 수행 요청임을 인식하고 서블릿 컨테이너에게 서블릿을 수행하도록 요청한다. 스레드를 하나 기동하여 해당 서블릿을 수행한다. 기동되었던 스레드를 종료하고 리턴한다. 섭르릿의 수행겨로가를 웹 서버에 전송한다. 출력 버퍼의 내용으로 HTTP 응답 헤더와 응답 바디를 구성하여 클라이언트로 전송한다. 브라우저로부터 WAS로 섭르릿 요청을 최초로 하는 경우와 두 번째 이후 요청인가에 따라서 처리되는 흐름이 약간 달라진다. 브라우저로부터 서블릿 수행 요청이 전송된다. 요청된 서블릿 클래스를 찾아서 메모리에 로딩한 후에 객체를 생성한다. init(ServletConfig) 메서드를 호출한다. service(ServletRequest, ServletResponse) 메서드를 호출한다. 요청 방식에 따라서 doGet() 또는 doPost() 메서드를 호출한다. 출력 버퍼의 내용을 요청을 보낸 브라우저로 리턴한다. 두 번째 이후부터의 요청인 경우에는 이미 생성되어 있는 서블릿 객체를 찾아서 다음과 같은 순서를 적용하여 서블릿을 수행시킨다. 브라우저로부터 서블릿 수행 요청이 전송된다. service(ServletRequest, ServletResponse) 메서드를 호출한다. 요청 방식에 따라서 doGet() 또는 doPost() 메서드를 호출한다. 출력 버퍼의 내용을 요청을 보낸 브라우저로 리턴한다. 위 그림에서는 서블릿의 수행 흐름 중 destroy()에 대한 언급이 생략되어 있다. destroy()는 브라우저로부터의 요청과 관계없이 메모리상에 생성된 서블릿 객체가 메모리 해제되는 시점에서 호출되는 메서드이다. 서블릿 객체가 메모리에서 해제되는 시점 컨테이너(서버)가 종료될 때 웹 어플리케이션이 리로드될 때 자동 리로드가 설정된 상태에서 서블릿이 재컴파일되었을 때 ​ 출처 구루비 서블릿 이해","categories":[{"name":"Web","slug":"Web","permalink":"https://sskim91.github.io/categories/Web/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://sskim91.github.io/tags/Servlet/"}]},{"title":"Thymeleaf란?","slug":"Web-Developer-20180112-Thymeleaf란","date":"2018-01-12T14:03:14.000Z","updated":"2018-05-09T07:15:32.020Z","comments":true,"path":"2018/01/12/Web-Developer-20180112-Thymeleaf란/","link":"","permalink":"https://sskim91.github.io/2018/01/12/Web-Developer-20180112-Thymeleaf란/","excerpt":"Thymeleaf는 템플릿 엔진 (Template Engine) 중에 하나로서 서버측 자바 템플릿 엔진(Java Template Engine)이다.","text":"Thymeleaf는 템플릿 엔진 (Template Engine) 중에 하나로서 서버측 자바 템플릿 엔진(Java Template Engine)이다. 스프링부트(Spring boot)를 보고 있는데 스프링에서 강하게 밀고있는 View 템플릿 엔진이라고 한다. 사실 템플릿 엔진이라는 말도 잘 모르는데 검색 좀 하고 알게됬다. 내가 지금까지 사용한 JSP도 템플릿 엔진 이였던 것 같다. 템플릿 엔진에는 JSP말고도 Java 라이브러리 템플릿 엔진인 Freemarker란 것도 있고 같은 Java 기반 템플릿 엔진인 Velocity 라는 것도 있다. 그리고 Thymeleaf도 템플릿 엔진이다. Thymeleaf의 장점은 일단 확장자가 HTML이란 점으로서 WAS의 실행 없이도 화면을 확인할 수가 있다. 간단하게 JSP는 WAS를 거쳐서 다시 HTML파일로 재 변환한 후에 웹 브라우저에서 보여지는 것인데 Thymeleaf는 그럴 필요가 없다. 즉 서버상에서 동작하지 않아도 된다는 점이다. 그리고 순수 HTML문서에 HTML5문법으로 서버사이드 로직을 수행하고 적용시킬 수 있다. 또한 태그 라이브러리를 사용하는 JSP에서는 다음과 같은 브라우저로 직접 표시할 수 없는 코드를 포함할 수 있다. Thymeleaf는 다른 템플릿 엔진처럼 전용 문법을 사용하지 않고 HTML 엘리먼트에 속성을 적어줌으로써 동작하기 때문에 Thymeleaf는 이를 해석해서 View 파일을 만들어주고 브라우저는 모르는 속성은 그냥 무시하므로 브라우저에서도 동작하게 된다. 태그 라이브러리를 사용하는 JSP 코드 1&lt;form:inputText name=\"userName\" value=\"$&#123;user.name&#125;\" /&gt; Thymeleaf 코드 1&lt;input type=\"text\" name=\"userName\" value=\"James Carrot\" th:value=\"$&#123;user.name&#125;\" /&gt; JSP코드는 서버에서 처리를 해주지 않으면 브라우저에 표시조차 되지 않지만 아래 Thymeleaf 코드는 브라우저에 의해 올바르게 표시될 뿐만 아니라 ${user.name}을 읽어오지 못하였더라도 위 경우에서는 James Carrot 이라는 값으로 대체 될 수 있다.","categories":[{"name":"Web","slug":"Web","permalink":"https://sskim91.github.io/categories/Web/"}],"tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://sskim91.github.io/tags/Thymeleaf/"}]},{"title":"mysql 조건부 데이터 입력, 변경","slug":"Database-20180110-mysql-조건부-데이터-입력-변경","date":"2018-01-10T07:40:39.000Z","updated":"2018-05-09T07:24:55.200Z","comments":true,"path":"2018/01/10/Database-20180110-mysql-조건부-데이터-입력-변경/","link":"","permalink":"https://sskim91.github.io/2018/01/10/Database-20180110-mysql-조건부-데이터-입력-변경/","excerpt":"","text":"DB는 기본 키가 중복된 데이터를 입력하는 것을 허용하지 않는다. 예를들어 100건을 입력하고자 하는데 첫 번째 한번의 오류 때문에 나머지 99건도 입력되지 않는 것도 문제가 될 수 있다. Mysql은 오류가 발생해도 계속 진행하는 방법을 제공한다.","categories":[{"name":"Database","slug":"Database","permalink":"https://sskim91.github.io/categories/Database/"},{"name":"MySQL","slug":"Database/MySQL","permalink":"https://sskim91.github.io/categories/Database/MySQL/"}],"tags":[{"name":"database","slug":"database","permalink":"https://sskim91.github.io/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"https://sskim91.github.io/tags/mysql/"}]},{"title":"DBMS 데이터베이스 관리 시스템","slug":"Database-20180110-DBMS-데이터베이스-관리-시스템","date":"2018-01-10T04:16:31.000Z","updated":"2018-05-09T07:24:25.203Z","comments":true,"path":"2018/01/10/Database-20180110-DBMS-데이터베이스-관리-시스템/","link":"","permalink":"https://sskim91.github.io/2018/01/10/Database-20180110-DBMS-데이터베이스-관리-시스템/","excerpt":"DBSM란?","text":"DBSM란? 데이터베이스 관리 시스템(영어: database management system, DBMS)은 다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합이다. DBMS은 사용자 또는 다른 프로그램의 요구를 처리하고 적절히 응답하여 데이터를 사용할 수 있도록 해준다. 위키백과 데이터베이스를 데이터의 집합체 이라고 정의한다면 DBMS는 이 데이터베이스를 관리 또는 운영하는 역할을 한다. DBMS는 데이터베이스를 관리하는 역할을 하는 소프트웨어의 개념이다. 또, 여러 명의 사용자나 응용프로그램이 이 DBMS가 관리하는 데이터에 동시에 접속하고 데이터를 공유하게 된다. DBMS의 특징 데이터의 무결성 데이터베이스 안의 데이터는 어떤 경로를 통해 들어 왔던지 데이터에 오류가 있어서는 안된다. 이 무결성(Integrity)을 위해서 데이터베이스는 제약 조건(Constrain)이라는 특성을 가진다. 데이터의 독립성 데이터베이스의 크기를 변경하거나 데이터 파일의 저장소를 변경하더라도 기존에 작성된 응용프로그램은 전혀 영향을 받지 않아야 한다. 즉, 서로 의존적 관계가 아닌 독립적인 관계여야 한다. 보안 데이터베이스 안의 데이터에 아무나 접근할 수 있는 것이 아니라 데이터를 소유한 사람이나 데이터에 접근이 허가된 사람만 접근할 수 있어야 한다. 또, 접근할 때도 사용자의 계정에 따라서 다른 권한을 가져야 한다. 데이터 중복의 최소화 동일한 데이터가 여러 개 중복되어 저장되는 것을 방지한다. 응용프로그램 제작 및 수정이 쉬워짐 기존 파일시스템을 사용할 때는 각각 파일의 포맷에 맞춰 개발해야 하는 응용프로그램을 데이터베이스를 이용함으로써 통일된 방식으로 응용프로그램 작성이 가능해지고, 유지보수 또한 쉬워진다. 데이터의 안전성 향상 대부분의 DBMS가 제공하는 백업과 복원 기능을 이용함으로써, 데이터가 깨지는 문제가 발생할 경우에 원상태로 복원 또는 복구하는 방법이 명확해진다. DBMS 분류 DBMS의 유형은 크게 계층형DBMS, 망형DBMS, 관계형DBMS, 객체지향형DBMS, 그리고 객체관계형DBMS 등으로 분류된다. 현재 사용되는 DBMS 중에는 관계형 DBMS가 가장 많은 부분을 차지하며, 일부 멀티미디어 분야에서 객체지향형이나 객체관계형 DBMS가 활용되고 있는 추세이다. MySQL과 더불어 Oracle, DB2, SQL Server, Access 등은 모두 관계형 DBMS 이다. 관계형 DBMS관계형 DBMS의 시초는 1969년 E.F.Codd라는 학자가 수학 모델에 근거해서 고안하면서 시작되었다. RDBMS의 핵심 개념은 데이터베이스는 테이블이라 불리는 최소 단위로 구성되어있다. 그리고 이 테이블은 하나 이상의 열로 구성되어 있다. 라고 생각하면 된다. 관계형 DBMS에서 모든 데이터는 테이블에 저장되므로 테이블이라는 구조가 RDBMS의 가장 기본적이고 중요한 구성이 된다. 관계형 DBMS의 장점과 단점장점 다른 DBMS에 비해서 쉽게 변화에 순응할 수 있는 구조 유지보수 측면에서도 편리한 특징을 가지고 있다. 대용량 데이터의 관리와 데이터 무결성의 보장 동시에 데이터에 접근하는 응용프로그램을 사용할 경우 RDBMS는 적절한 선택 단점 시스템 자원을 많이 차지하므로 시스템이 전반적으로 느려짐 그러나 최근에는 하드웨어의 급속한 발전으로 인해서 이러한 단점은 많이 보완되고 있다. SQL(Structured Query Language)SQL은 관계형 데이터베이스에서 사용되는 언어이다. 관계형 DBMS를 배우고자 한다면 SQL을 익혀야 하는 것은 필수이다. SQL의 특징 DBMS 제작 회사와 독립적이다. SQL은 모든 DBMS 제작회사에서 공통적으로 공개되고 각 제작회사는 이 표준 SQL에 맞춰서 DBMS를 개발한다. 그러므로 표준 SQL은 대부분의 DBMS 제품에서 공통적으로 호환된다. 다른 시스템으로의 이식성이 좋다 SQL 표준은 서버용, 개인용, 휴대용 장비에서 운영되는 DBMS마다 상호 호환성이 뛰어나다. 그러므로 어느 곳에서 사용된 SQL을 다른 시스템으로 이식하는 데 별 문제가 없다. 표준이 계속 발전한다. 대화식 언어이다. 기존 프로그래밍 언어는 프로그램 작성, 컴파일 및 디버깅, 실행이라는 과정을 거쳐야만 그 결과를 확인할 수 있었으나 SQL은 이와 달리 바로 질의하고 결과를 얻는 대화식 언어로 구성되어 있다. 분산형 클라이언트/서버 구조이다. SQL은 분산형 구조인 클라이언트/서버 구조를 지원한다. 즉, 클라이언트에서 질의를 하면 서버에서 그 질의를 받아서 처리한 후, 다시 클라이언트에게 전달하는 구조를 가진다. 주의할 점은 모든 DBMS의 SQL문이 완벽하게 동일하지는 않다. 많은 DBMS 벤더들이 표준 SQL을 준수하려고 하지만 각 벤더마다 특징이 있기에 현실적으로 완전히 통일되기는 어렵다. 그래서 각 회사는 표준 SQL을 지키면서도 자신의 제품에 특화시킨 SQL을 사용한다. Oracle은 PL/SQL SQL Server는 T-SQL MySQL는 그냥 SQL 출처 위키백과 책 이것이 MySQL이다.","categories":[{"name":"Database","slug":"Database","permalink":"https://sskim91.github.io/categories/Database/"},{"name":"MySQL","slug":"Database/MySQL","permalink":"https://sskim91.github.io/categories/Database/MySQL/"}],"tags":[{"name":"database","slug":"database","permalink":"https://sskim91.github.io/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"https://sskim91.github.io/tags/mysql/"}]},{"title":"Java String 클래스 메소드 정리","slug":"Java-20180106-Java-String-정리","date":"2018-01-06T04:14:22.000Z","updated":"2018-05-09T07:35:23.464Z","comments":true,"path":"2018/01/06/Java-20180106-Java-String-정리/","link":"","permalink":"https://sskim91.github.io/2018/01/06/Java-20180106-Java-String-정리/","excerpt":"자바의 String 클래스는 문자열을 저장하고 사용하는데 쓰인다.","text":"자바의 String 클래스는 문자열을 저장하고 사용하는데 쓰인다. 보통 문자 하나는 기본형인 char 형을 쓰고 문자열 을 사용할 때는 String 클래스를 사용한다. String도 클래스이기 때문에 메소드가 존재한다. 문자열 연산을 위한 기본 메소드concat(String str) 메소드 대상 문자열 뒤에 매개변수 str 문자열을 덧붙인 새로운 문자열을 반환한다. 12\"ABC\".concat(\"DEF\");//결과: ABCDEF substring(int beginIndex) 메소드대상 문자열에서 매개변수 beginIndex 위치에 있는 문자열을 새롭게 반환한다. beginIndex는 0부터 시작한다. 1234\"ABCD\".substring(0);//결과: ABCD\"ABCD\".substring(3);//결과: D substring(int beginIndex, int endIndex) 메소드문자열에서 beginIndex와 endIndex 위치 사이에 있는 문자열을 새롭게 반환한다. 그러므로 endIndex의 값은 반드시 beginIndex의 값보다 커야 한다. 문자를 자르는 기능을 한다. 12\"ABCDE\".substring(3,5);//결과: DE replace(Char oldChar, Char newChar) 메소드대상 문자열에서 oldChar 문자를 newChar 문자로 바꾼 새로운 문자열을 반환한다. 12\"ABCDE\".replace('A','a');//결과: aBCDE replace(CharSequence t, CharSequence r) 메소드대상 문자열에서 바꾸고 싶은 문자열 t를 문자열 r로 바꾸어 새로운 문자열을 반환한다. 12\"ABCDE\".replace(\"ABC\",\"abc\");//결과: \"abcDE\" toLowerCase() 메소드문자열의 문자들을 모두 소문자로 바꾸어 새로운 문자열을 반환한다. 12\"Target String\".toLowerCase();//결과: target string\" toUpperCase() 메소드문자열의 문자들을 모두 대문자로 바꾸어 새로운 문자열을 반환한다. 12\"Target String\".toUpperCase();//결과: TARGET STRING\" 문자열 비교를 위한 메소드equals(Object anObject) 메소드대상 문자열이 anObject 데이터(객체)와 같은지 비교해서 boolean 값을 반환한다. 12\"ABC\".equals(\"DEF\");//결과: false compareTo(String str) 메소드대상 문자열이 사전적으로 앞에 있는지 뒤에 있는지 확인한다. 반환값이 0이면 두 문자열은 같고, 양수면 대상 문자열이 str보다 뒤에 있고, 음수면 대상 문자열이 str보다 앞에 있다. 12\"a\".compareTo(\"c\");//결과: -2 startWith(String prefix) 메소드대상 문자열이 매개변수로 받은 접두사(prefix) 문자열로 시작하는지 확인한 후 boolean 값을 반환한다. 12\"ABCDE\".startWith(\"ABC\");//결과: true endWith(String suffix) 메소드대상 문자열이 매개변수로 받은 접미사(suffix) 문자열로 끝나는지 확인한 후 boolean 값을 반환한다. 12\"ABCDE\".endWith(\"DE\");//결과: true 특정 문자열 위치 파악을 위한 메소드indexOf(int ch) 메소드주어진 문자(ch)가 문자열에 존재하는지 확인하여 위치(index)를 알려준다. 못 찾으면 -1을 반환한다. (index는 0부터 시작) 1234\"HELLO\".indexOf('O');//결과: 4\"HELLO\".indexOf('K');//결과: -1 indexOf(int ch, int pos) 메소드주어진 문자(ch)가 문자열에 존재하는지 지정된 위치(pos)부터 확인하여 위치(index)를 알려준다. 못 찾으면 -1을 반환한다. (index는 0부터 시작) 1234\"HELLO\".indexOf('E', 0);//결과: 1\"HELLO\".indexOf('E', 2);//결과: -1 indexOf(String str) 메소드대상 문자열에서 str 문자가 앞에서부터 맨 처음 시작하는 위치(index)를 반환한다. (index는 0부터 시작) 포함되어 있지 않으면 -1을 반환한다. 12\"ABCDE\".indexOf(\"B\");//결과: 1 lastIndexOf(int ch) 메소드지정된 문자 또는 문자코드를 문자열의 오른쪽 끝에서부터 찾아서 위치(index)를 알려준다. 못 찾으면 -1을 반환한다. 1234\"java.lang.Object\".lastIndexOf('.');//결과: 9\"java.lang.Object\".indexOf('.');//결과: 4 lastIndexOf(String str) 메소드대상 문자열에서 str 문자가 뒤에서부터 맨 처음 시작하는 위치(index)를 반환한다. 12\"ABCDEABC\".lastIndexOf(\"A\");//결과: 5 문자열 구분을 위한 메소드split(String regex) 메소드문자열을 지정된 분리자(regex)로 나누어 문자열 배열에 담아 반환한다. 12345String animals = \"dog,cat,bear\";String[] arr = animals.split(\",\");//결과 : arr[0] = \"dog\" arr[1] = \"cat\" arr[2] = \"bear\" Java8 부터 새롭게 추가된 메소드join(CharSequence delimiter, CharSequence... elements) 메소드join 메소드 파라미터를 살펴보면 delimiter 구분문자 가 들어가고 … elements 요소가 들어간다. 자바에서 …은 파라미터를 여러개 받을수 있는 구조이다. 자동으로 배열처리가 된다. Array나 list도 받을 수 있다. 여러 문자열 사이에 구분자를 넣어서 결합하는 메소드로 구분자로 문자열을 자르는 split()과 반대의 작업을 한다고 생각하면 된다. 예제를 본다면 그냥 이렇게 사용하는 구나 하고 알 수 있을것이다. 구분자로 문자열 Join 123String result = String.join(\"-\", \"2018\",\"01\",\"22\");System.out.println(result);//결과: 2018-01-22 구분자에 의해서 배열에 Join 1234List&lt;String&gt; list = Arrays.asList(\"java\", \"python\", \"nodejs\", \"ruby\");String result = String.join(\"-_-\", list);System.out.println(result);//결과: java-_-python-_-nodejs-_-ruby","categories":[{"name":"Programming","slug":"Programming","permalink":"https://sskim91.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://sskim91.github.io/categories/Programming/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sskim91.github.io/tags/Java/"},{"name":"String","slug":"String","permalink":"https://sskim91.github.io/tags/String/"}]},{"title":"라즈베리파이3 라즈비안 설치","slug":"RaspberryPI3-20180105-라즈베리파이3-라즈비안-설치","date":"2018-01-04T15:03:04.000Z","updated":"2018-05-09T07:18:30.967Z","comments":true,"path":"2018/01/05/RaspberryPI3-20180105-라즈베리파이3-라즈비안-설치/","link":"","permalink":"https://sskim91.github.io/2018/01/05/RaspberryPI3-20180105-라즈베리파이3-라즈비안-설치/","excerpt":"라즈베리파이3를 구입하고 라즈비안 OS를 설치","text":"라즈베리파이3를 구입하고 라즈비안 OS를 설치 1. OS 이미지 다운로드라즈비안OS 다운로드 공식사이트로 이동해서 디스크 이미지를 다운 받습니다. 왼쪽에 있는 DESKTOP은 GUI가 포함된 OS 이고 오른쪽에 LITE는 콘솔모드로만 이용할 수 있습니다.맨 처음에 GUI가 포함된 파일로 설치를 했었는데 기본적으로 깔려있는 것이 너무 많아서 다시 LITE로 설치했습니다. 일단 필요한 OS를 받았고 다운받은 디스크 이미지를 이제 SD카드에 이미지를 써야 합니다. 2. SD카드 포맷디스크 이미지를 쓰기 전에 SD카드를 포맷할 필요가 있습니다. sd카드 포맷 다운로드 로 이동해서 자신의 운영체제에 맞는 sd카드 포맷 프로그램을 다운받아서 설치하면 됩니다. sd카드가 들어있는 디스크를 선택하고 포맷버튼을 클릭해서 포맷을 하면 됩니다. 3. SD카드 이미지 쓰기포맷한 SD카드에 이제 다운받은 라즈비안os를 쓰면 됩니다. window와 macOS 별로 이미지를 쓰는 방법이 다 있지만 저는 데스크탑으로 사용하고 있는 window로 이미지를 굽겠습니다. 이미지를 구울때 필요한 프로그램을 다운로드 받습니다. win32diskimager ==&gt; 링크를 누르면 다운로드 주소로 이동됩니다. 프로그램을 설치하고 실행합니다. 다운받은 이미지 파일을 선택해서 sd카드가 꽂혀있는 드라이브를 선택해서 Write를 시작합니다.대략 5분정도 걸리는 것 같습니다. 이미지를 다 쓰고나서 window의 경우 디스크 형식이 linux이기 때문에 포맷을 하시겠습니까? 라는 경고창이 뜨는데그냥 취소를 누르면 됩니다. macOS 이미지 굽는 방법링크로 대체하겠습니다. Raspberry Pi 라즈비안 설치하기 (맥 OS) 4. 라즈비안OS 설치하기이제 sd카드를 라즈베리파이에 삽입하고 전원을 연결하면 부팅이 시작됩니다. 5. 라즈비안 OS 초기 아이디/비밀번호 아이디 pi 비밀번호 raspberry","categories":[{"name":"라즈베리파이","slug":"라즈베리파이","permalink":"https://sskim91.github.io/categories/라즈베리파이/"}],"tags":[{"name":"RaspberryPI3","slug":"RaspberryPI3","permalink":"https://sskim91.github.io/tags/RaspberryPI3/"}]}]}